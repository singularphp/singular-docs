{
    "docs": [
        {
            "location": "/", 
            "text": "Instala\u00e7\u00e3o\n#\n\n\nPr\u00e9-requisitos\n#\n\n\nAntes de iniciar, certifique-se de que seu ambiente possui instalados os seguintes pr\u00e9-requisitos:\n\n\n\n\nPHP \n= 5.6;\n\n\nMySQL \n= 5.6;\n\n\nComposer;\n\n\n\n\nCriando um novo projeto\n#\n\n\nPara criar um novo projeto com o singular-project, basta executar o comando:\n\n\ncomposer create-project singular/singular-project nomedoprojeto --stability=dev\n\n\n\n\n\n\nOnde\n\n\n\n\nnomedoprojeto\n dever\u00e1 ser substitu\u00eddo pelo nome do seu projeto.\n\n\nAo utilizar a op\u00e7\u00e3o \n--stability=dev\n, voc\u00ea estar\u00e1 garantindo que seu projeto ir\u00e1 conter todas as atualiza\u00e7\u00f5es mais recentes do Singular Framework.\n\n\n\n\n\n\n\n\nEstrutura do projeto\n#\n\n\nAp\u00f3s criar o projeto, ser\u00e1 criado um diret\u00f3rio nomeado com o \nnomedoprojeto\n com a seguinte\nestrutura de arquivos:\n\n\n app\n\n db\n\n src\n\n vendor\n\n views\n\n web\n  composer.json\n  composer.lock\n  phinx.yml\n  README.md\n  singular  \n\n\n\n\nO Diret\u00f3rio app\n#\n\n\nO diret\u00f3rio \napp\n \u00e9 onde est\u00e3o armazenados todos os arquivos de configura\u00e7\u00e3o e inicializa\u00e7\u00e3o do projeto. \nEle cont\u00e9m 6 subdiret\u00f3rios.\n\n\n\n\nconfig\n: Diret\u00f3rio onde s\u00e3o armazenados todos os arquivos de configura\u00e7\u00e3o do projeto;\n\n\nfilters\n: Diret\u00f3rio onde s\u00e3o armazenados os \nmiddlewares\n da aplica\u00e7\u00e3o;\n\n\npacks\n: Diret\u00f3rio onde s\u00e3o armazenados os provedores de servi\u00e7o dos pacotes habilitados na aplica\u00e7\u00e3o;\n\n\nproviders\n: Diret\u00f3rio onde s\u00e3o armazenados os \nprovedores de servi\u00e7o de terceiros\n;\n\n\nservices\n: Diret\u00f3rio onde s\u00e3o armazenados os scritps de defini\u00e7\u00e3o de \nservi\u00e7os\n globais da aplica\u00e7\u00e3o;\n\n\ntmp\n: Diret\u00f3rio onde s\u00e3o armazenados os arquivos tempor\u00e1rios de log e gerenciamento de sess\u00e3o da aplica\u00e7\u00e3o;\n\n\n\n\nDiret\u00f3rio db\n#\n\n\nPara gerenciar as migra\u00e7\u00f5es de banco de dados da aplica\u00e7\u00e3o, o Singular Project utiliza o \nPhinx\n. \n\n\nO diret\u00f3rio \ndb\n \u00e9 onde est\u00e3o armazenadas as migrations do projeto, dentro do subdiret\u00f3rio \nmigrations\n. \nEsse diret\u00f3rio tamb\u00e9m poder\u00e1 vir a armazenar os arquivos de \nseed\n para testes no banco de dados. \nEntretanto, para alimentar o banco de dados com registros necess\u00e1rios ao projeto, dever\u00e3o ser utilizadas as migrations \nconvencionais atrav\u00e9s dos m\u00e9todos \nup\n e \ndown\n.\n\n\nQuando um novo projeto \u00e9 criado, algumas migrations j\u00e1 encontram-se presentes neste diret\u00f3rio, \u00e0 frente veremos como \nexecut\u00e1-las para poder come\u00e7ar a utilizar o projeto funcional do singular project.\n\n\nDiret\u00f3rio src\n#\n\n\nO diret\u00f3rio \nsrc\n \u00e9 onde encontram-se armazenados os scripts de c\u00f3digo fonte php do projeto. \nCada pacote criado para a aplica\u00e7\u00e3o, dever\u00e1 ter um subdiret\u00f3rio dentro do diret\u00f3rio src. \nMais adiante veremos como criar um novo pacote e como um pacote encontra-se estruturado. \n\n\nDiret\u00f3rio vendor\n#\n\n\nO diret\u00f3rio \nvendor\n \u00e9 criado automaticamente pelo \nComposer\n, \ngerenciador de pacotes e depend\u00eancias php da aplica\u00e7\u00e3o.\n\n\nDiret\u00f3rio views\n#\n\n\nO diret\u00f3rio \nviews\n \u00e9 onde s\u00e3o armazenados os scripts html que s\u00e3o os templates \nTwig\n \ndas p\u00e1ginas do projeto. Esse diret\u00f3rio j\u00e1 possui dois arquivos principais de templates:\n\n\n\n\nauth.html\n Template da view exibida quando o usu\u00e1rio ainda n\u00e3o est\u00e1 logado na aplica\u00e7\u00e3o;\n\n\nsecure.html\n Template da view exibida quando o usu\u00e1rio j\u00e1 est\u00e1 logado no sistema;\n\n\n\n\nPoder\u00e3o ser criadas tantos templates quanto necess\u00e1rio, por exemplo, podem ser criados templates html para cria\u00e7\u00e3o \nde relat\u00f3rios pdf.\n\n\nVisto que o Singular Framework emprega 100% do conceito \nAJAX\n \natrav\u00e9s do \nAngularJS\n, o diret\u00f3rio views, n\u00e3o dever\u00e1 ser utilizado para armazenar templates \nde interface dos m\u00f3dulos da aplica\u00e7\u00e3o, mas templates que fornecem renderiza\u00e7\u00e3o aos m\u00f3dulos do AngularJS.\n\n\nDiret\u00f3rio web\n#\n\n\nO diret\u00f3rio web \u00e9 onde encontram-se armazenados todos os scripts de front-end da aplica\u00e7\u00e3o. \u00c9 nele que voc\u00ea ir\u00e1 criar \nseus scripts javascript de m\u00f3dulos, controladores, servi\u00e7os e templates do AngularJS. \n\n\nEste diret\u00f3rio cont\u00e9m:\n\n\n\n\nassets\n diret\u00f3rio onde s\u00e3o armazenados scripts css, fontes, imagens e bibliotecas front-end de \nterceiros;\n\n\nsrc\n diret\u00f3rio onde s\u00e3o armazenados os scripts de c\u00f3digo fonte javascript do seu projeto;\n\n\nholder.js\n script javascript que gera imagens placeholders, que podem ser utilizados em telas e \ninterfaces do seu projeto;\n\n\nindex.php\n script php principal da aplica\u00e7\u00e3o. Ele \u00e9 o ponto de entrada da sua aplica\u00e7\u00e3o, nele a \nsua aplica\u00e7\u00e3o \u00e9 iniciada e todas as chamadas, AJAX ou convencionais passam por este script.\n\n\n\n\nArquivo composer.json\n#\n\n\nArquivo que cont\u00e9m a rela\u00e7\u00e3o das depend\u00eancias das bibliotecas php do projeto. \n\n\nArquivo phinx.yml\n#\n\n\nComo mencionado anteriormente, o projeto baseado no Singular utiliza o Phinx como gerenciador  de migrations do banco \nde dados da aplica\u00e7\u00e3o. O Phinx por sua vez, \u00e9 configurado atrav\u00e9s deste arquivo.\n\n\nArquivo singular\n#\n\n\nO Singular project utiliza o Singular Command para fornecer tarefas de linha de comando que automatizam a maioria \ndos processos repetitivos do desenvolvimento de um projeto. Mais adiante iremos ver em detalhes como utilizar essa \nferramenta e quais comandos est\u00e3o dispon\u00edveis para utiliza\u00e7\u00e3o.\n\n\n\n\nConfigura\u00e7\u00e3o\n#\n\n\nConfigurando o Virtual host\n#\n\n\nPara que seu projeto rode de forma simples na sua m\u00e1quina, \u00e9 necess\u00e1rio primeiramente configurar um virtual host no \nservidor web. Na Net On, utilizamos o \nMAMP\n em nosso ambiente de desenvolvimento, por isso, vamos \nver como configurar o virtual host para este ambiente. \n\n\nA utiliza\u00e7\u00e3o do virtual host permitir\u00e1 que voc\u00ea realize seus testes durante o desenvolvimento de forma muito mais \nf\u00e1cil, ao inv\u00e9s de acessar no navegador um endere\u00e7o como \nhttp://localhost/nomedoprojeto/web\n podemos fazer algo do \ntipo \nhttp://nomedoprojeto.local/\n\n\n1. Crie uma entrada no arquivo hosts\n#\n\n\nPelo terminal da sua m\u00e1quina, abra o arquivo /etc/host\n\n\nsudo vim /etc/hosts\n\n\n\n\nAdicione a seguinte linha no arquivo, lembrando sempre de trocar o \nnomedoprojeto\n pelo nome do seu \nprojeto.\n\n\n...\n127.0.0.1 sng.local # trocar sng pelo nome do seu projeto\n...\n\n\n\n\nSalve e feche o arquivo.\n\n\n2. Crie o arquivo de configura\u00e7\u00e3o do virtual host no MAMP\n#\n\n\nAbra o arquivo de configura\u00e7\u00f5es de virtual hosts pelo terminal:\n\n\nsudo vim /Applications/MAMP/conf/apache/extra/httpd-vhosts.conf \n\n\n\n\nE adicione o seguinte bloco de c\u00f3digo ao final do arquivo:\n\n\nVirtualHost *:80\n\n    DocumentRoot \n/htdocs/sng/web\n # trocar pelo caminho do diret\u00f3rio web completo do seu projeto\n    ServerName sng.local # trocar sng pelo nome do seu projeto\n\n/VirtualHost\n\n\n\n\nSalve e feche o seu arquivo e, em seguida, reinicie o servi\u00e7o do apache do seu MAMP. Agora, dever\u00e1 ser poss\u00edvel \nacessar o projeto atrav\u00e9s do seu navegador web. Para isso basta digitar na barra de endere\u00e7os \nhttp://sng.local/\n. \nSe voc\u00ea se deparar com alguma mensagem de erro relacionado \u00e0 permiss\u00e3o em diret\u00f3rios, basta conceder as permiss\u00f5es \nde escrita no diret\u00f3rio e tentar novamente. \n\n\nAgora voc\u00ea deve visualizar em seu navegador uma tela semelhante a esta:\n\n\nEntretanto, ainda n\u00e3o \u00e9 poss\u00edvel acessar o sistema nem mesmo come\u00e7ar a desenvolver seus pr\u00f3prios m\u00f3dulos. Para isso, \nprecisamos seguir com a configura\u00e7\u00e3o.\n\n\nCriando o banco de dados\n#\n\n\nNo seu SGBD, crie um novo banco de dados banco de dados com o nome definido para a base de dados do seu projeto.\n\n\nConfigurando o PHINX\n#\n\n\nPara gerenciar as migrations de banco de dados, o Singular Project utiliza o Phinx. Ele j\u00e1 est\u00e1 inclu\u00eddo no projeto \ncomo depend\u00eancia, no entanto, \u00e9 necess\u00e1rio configur\u00e1-lo. \n\n\nAbra o arquivo \nphinx.yml\n localizado no diret\u00f3rio raiz do seu projeto e, em seguida:\n\n\n\n\n\n\nDuplique o bloco de configura\u00e7\u00e3o \nbase\n e altere o nome desse novo bloco para \ndev-seunome\n \nsubstitu\u00edndo o \nseunome\n pelo seu primeiro nome, sem acentua\u00e7\u00e3o e todo em min\u00fasculo. \n\n\n\n\n\n\nNo seu bloco de configura\u00e7\u00e3o, altere as configura\u00e7\u00f5es de endere\u00e7o da base de dados, senha, usu\u00e1rio e nome da base \nde dados;\n\n\n\n\n\n\nO resultado final dever\u00e1 ser algo como:\n\n\n...\n dev-otavio:\n        adapter: mysql\n        host: localhost\n        name: sng\n        user: root\n        pass: 'root'\n        port: 3306\n        charset: utf8\n\n\n\n\nSalve e feche o arquivo. Agora \u00e9 necess\u00e1rio configurar o ambiente padr\u00e3o de execu\u00e7\u00e3o do Phinx no seu ambiente. \nAbra o seu terminal e digite o seguinte c\u00f3digo:\n\n\n export PHINX_ENVIRONMENT=dev-seunome # substituindo seunome pelo nome do bloco que voc\u00ea criou.\n\n\n\n\nFinalmente, pelo terminal, dentro da pasta do seu projeto, execute o comando:\n\n\nvendor/bin/phinx status\n\n\n\n\nO resultado dever\u00e1 ser algo semelhante a:\n\n\n Status  [Migration ID]  Started              Finished             Migration Name \n----------------------------------------------------------------------------------\n   down  20170630140758                                            CriaTabelaSingularAplicacao\n   down  20170630144050                                            CriaTabelaSingularModulo\n   down  20170701171751                                            InsereRegistrosIniciaisSingular\n   down  20170701173743                                            CriaTabelaSingularPerfil\n   down  20170701174500                                            CriaTabelaSingularComponente\n   down  20170701175748                                            CriaTabelaSingularPermissao\n   down  20170703224706                                            CriaTabelaSingularUsuario\n   down  20170827183316                                            InsereRegistroPerfilUsuario\n   down  20170918230051                                            InsereRegistroModuloUsuario\n   down  20171002180438                                            InsereRegistroModuloComponente\n   down  20171004103414                                            InsereRegistrosComponentes1507124054\n   down  20171006084220                                            InsereRegistrosComponentes1507290140\n\n\n\n\nPor hora, \u00e9 o suficiente, ainda n\u00e3o iremos executar as migrations.\n\n\nConfigurando o banco de dados\n#\n\n\nCrie uma c\u00f3pia do arquivo \napp/config/database.json\n e a nomeie de \napp/config/local.json\n dentro do mesmo diret\u00f3rio. \nAgora, altere as configura\u00e7\u00f5es do banco de dados neste arquivo de acordo com seu ambiente e adicione a propriedade \n\npriority\n com o valor 100. O resultado final ser\u00e1 semelhante a:\n\n\n{\n  \n_priority\n: 100,\n  \ndb.driver\n: \nmysql\n,\n  \ndb.name\n: \nsng\n, \n  \ndb.host\n: \nlocalhost\n,\n  \ndb.user\n: \nroot\n,\n  \ndb.pass\n: \nroot\n,\n  \ndb.charset\n: \nutf8\n,\n  \ndb.collation\n: \nutf8_unicode_ci\n\n}\n\n\n\n\nInicializando a aplica\u00e7\u00e3o\n#\n\n\nPronto, agora, todo o ambiente est\u00e1 pronto para iniciar o desenvolvimento, vamos ent\u00e3o executar nossas migrations e \ncome\u00e7ar a trabalhar. Para isso, no terminal, digite:\n\n\nvendor/bin/phinx migrate\n\n\n\n\nSe tudo correu bem, o resultado ser\u00e1 parecido com:\n\n\nneton-alpha:sng oaugustus$ vendor/bin/phinx migrate\nPhinx by Rob Morgan - https://phinx.org. 0.8.1\n\nusing config file ./phinx.yml\nusing config parser yaml\nusing migration paths \n - /htdocs/sng/db/migrations\nusing seed paths \nwarning no environment specified, defaulting to: dev-otavio\nusing adapter mysql\nusing database sng\n\n == 20170630140758 CriaTabelaSingularAplicacao: migrating\n == 20170630140758 CriaTabelaSingularAplicacao: migrated 0.0215s\n\n == 20170630144050 CriaTabelaSingularModulo: migrating\n == 20170630144050 CriaTabelaSingularModulo: migrated 0.0217s\n\n == 20170701171751 InsereRegistrosIniciaisSingular: migrating\n == 20170701171751 InsereRegistrosIniciaisSingular: migrated 0.0053s\n\n == 20170701173743 CriaTabelaSingularPerfil: migrating\n == 20170701173743 CriaTabelaSingularPerfil: migrated 0.0196s\n\n == 20170701174500 CriaTabelaSingularComponente: migrating\n == 20170701174500 CriaTabelaSingularComponente: migrated 0.0180s\n\n == 20170701175748 CriaTabelaSingularPermissao: migrating\n == 20170701175748 CriaTabelaSingularPermissao: migrated 0.0169s\n\n == 20170703224706 CriaTabelaSingularUsuario: migrating\n == 20170703224706 CriaTabelaSingularUsuario: migrated 0.0212s\n\n == 20170827183316 InsereRegistroPerfilUsuario: migrating\n == 20170827183316 InsereRegistroPerfilUsuario: migrated 0.0049s\n\n == 20170918230051 InsereRegistroModuloUsuario: migrating\n == 20170918230051 InsereRegistroModuloUsuario: migrated 0.0032s\n\n == 20171002180438 InsereRegistroModuloComponente: migrating\n == 20171002180438 InsereRegistroModuloComponente: migrated 0.0023s\n\n == 20171004103414 InsereRegistrosComponentes1507124054: migrating\n == 20171004103414 InsereRegistrosComponentes1507124054: migrated 0.0034s\n\n == 20171006084220 InsereRegistrosComponentes1507290140: migrating\n == 20171006084220 InsereRegistrosComponentes1507290140: migrated 0.0047s\n\nAll Done. Took 0.1754s\n\n\n\n\nAinda no terminal, digite o comando:\n\n\n./singular component:grant-full-access 1\n\n\n\n\nE a mensagem:\n\n\nAcesso garantido para o perfil 1!\n\n\n\n\nIr\u00e1 aparecer. Agora, podemos acessar nosso novo sistema. Acesse a tela de login pelo endere\u00e7o \nhttp://nomeprojeto.local/\n \ne digite o usu\u00e1rio e senha de acesso:\n\n\n\n\nLogin\n: singular\n\n\nSenha\n: singular\n\n\n\n\nVoc\u00ea ser\u00e1 autenticado no sistema e redirecionado para o acesso restrito. A interface agora ser\u00e1 a seguinte:\n\n\n \n\n\nPerfeito! Agora podemos come\u00e7ar a codificar nosso novo sistema. No restante da documenta\u00e7\u00e3o iremos aprender a criar \nm\u00f3dulos, adicionar funcionalidades, restringir o acesso de perfis de usu\u00e1rio, e a utilizar as classes utilit\u00e1rias para \nagilizar nosso servi\u00e7o de desenvolvimento.", 
            "title": "Come\u00e7ando"
        }, 
        {
            "location": "/#instalacao", 
            "text": "", 
            "title": "Instala\u00e7\u00e3o"
        }, 
        {
            "location": "/#pre-requisitos", 
            "text": "Antes de iniciar, certifique-se de que seu ambiente possui instalados os seguintes pr\u00e9-requisitos:   PHP  = 5.6;  MySQL  = 5.6;  Composer;", 
            "title": "Pr\u00e9-requisitos"
        }, 
        {
            "location": "/#criando-um-novo-projeto", 
            "text": "Para criar um novo projeto com o singular-project, basta executar o comando:  composer create-project singular/singular-project nomedoprojeto --stability=dev   Onde   nomedoprojeto  dever\u00e1 ser substitu\u00eddo pelo nome do seu projeto.  Ao utilizar a op\u00e7\u00e3o  --stability=dev , voc\u00ea estar\u00e1 garantindo que seu projeto ir\u00e1 conter todas as atualiza\u00e7\u00f5es mais recentes do Singular Framework.", 
            "title": "Criando um novo projeto"
        }, 
        {
            "location": "/#estrutura-do-projeto", 
            "text": "Ap\u00f3s criar o projeto, ser\u00e1 criado um diret\u00f3rio nomeado com o  nomedoprojeto  com a seguinte\nestrutura de arquivos:   app  db  src  vendor  views  web\n  composer.json\n  composer.lock\n  phinx.yml\n  README.md\n  singular", 
            "title": "Estrutura do projeto"
        }, 
        {
            "location": "/#o-diretorio-app", 
            "text": "O diret\u00f3rio  app  \u00e9 onde est\u00e3o armazenados todos os arquivos de configura\u00e7\u00e3o e inicializa\u00e7\u00e3o do projeto. \nEle cont\u00e9m 6 subdiret\u00f3rios.   config : Diret\u00f3rio onde s\u00e3o armazenados todos os arquivos de configura\u00e7\u00e3o do projeto;  filters : Diret\u00f3rio onde s\u00e3o armazenados os  middlewares  da aplica\u00e7\u00e3o;  packs : Diret\u00f3rio onde s\u00e3o armazenados os provedores de servi\u00e7o dos pacotes habilitados na aplica\u00e7\u00e3o;  providers : Diret\u00f3rio onde s\u00e3o armazenados os  provedores de servi\u00e7o de terceiros ;  services : Diret\u00f3rio onde s\u00e3o armazenados os scritps de defini\u00e7\u00e3o de  servi\u00e7os  globais da aplica\u00e7\u00e3o;  tmp : Diret\u00f3rio onde s\u00e3o armazenados os arquivos tempor\u00e1rios de log e gerenciamento de sess\u00e3o da aplica\u00e7\u00e3o;", 
            "title": "O Diret\u00f3rio app"
        }, 
        {
            "location": "/#diretorio-db", 
            "text": "Para gerenciar as migra\u00e7\u00f5es de banco de dados da aplica\u00e7\u00e3o, o Singular Project utiliza o  Phinx .   O diret\u00f3rio  db  \u00e9 onde est\u00e3o armazenadas as migrations do projeto, dentro do subdiret\u00f3rio  migrations . \nEsse diret\u00f3rio tamb\u00e9m poder\u00e1 vir a armazenar os arquivos de  seed  para testes no banco de dados. \nEntretanto, para alimentar o banco de dados com registros necess\u00e1rios ao projeto, dever\u00e3o ser utilizadas as migrations \nconvencionais atrav\u00e9s dos m\u00e9todos  up  e  down .  Quando um novo projeto \u00e9 criado, algumas migrations j\u00e1 encontram-se presentes neste diret\u00f3rio, \u00e0 frente veremos como \nexecut\u00e1-las para poder come\u00e7ar a utilizar o projeto funcional do singular project.", 
            "title": "Diret\u00f3rio db"
        }, 
        {
            "location": "/#diretorio-src", 
            "text": "O diret\u00f3rio  src  \u00e9 onde encontram-se armazenados os scripts de c\u00f3digo fonte php do projeto. \nCada pacote criado para a aplica\u00e7\u00e3o, dever\u00e1 ter um subdiret\u00f3rio dentro do diret\u00f3rio src. \nMais adiante veremos como criar um novo pacote e como um pacote encontra-se estruturado.", 
            "title": "Diret\u00f3rio src"
        }, 
        {
            "location": "/#diretorio-vendor", 
            "text": "O diret\u00f3rio  vendor  \u00e9 criado automaticamente pelo  Composer , \ngerenciador de pacotes e depend\u00eancias php da aplica\u00e7\u00e3o.", 
            "title": "Diret\u00f3rio vendor"
        }, 
        {
            "location": "/#diretorio-views", 
            "text": "O diret\u00f3rio  views  \u00e9 onde s\u00e3o armazenados os scripts html que s\u00e3o os templates  Twig  \ndas p\u00e1ginas do projeto. Esse diret\u00f3rio j\u00e1 possui dois arquivos principais de templates:   auth.html  Template da view exibida quando o usu\u00e1rio ainda n\u00e3o est\u00e1 logado na aplica\u00e7\u00e3o;  secure.html  Template da view exibida quando o usu\u00e1rio j\u00e1 est\u00e1 logado no sistema;   Poder\u00e3o ser criadas tantos templates quanto necess\u00e1rio, por exemplo, podem ser criados templates html para cria\u00e7\u00e3o \nde relat\u00f3rios pdf.  Visto que o Singular Framework emprega 100% do conceito  AJAX  \natrav\u00e9s do  AngularJS , o diret\u00f3rio views, n\u00e3o dever\u00e1 ser utilizado para armazenar templates \nde interface dos m\u00f3dulos da aplica\u00e7\u00e3o, mas templates que fornecem renderiza\u00e7\u00e3o aos m\u00f3dulos do AngularJS.", 
            "title": "Diret\u00f3rio views"
        }, 
        {
            "location": "/#diretorio-web", 
            "text": "O diret\u00f3rio web \u00e9 onde encontram-se armazenados todos os scripts de front-end da aplica\u00e7\u00e3o. \u00c9 nele que voc\u00ea ir\u00e1 criar \nseus scripts javascript de m\u00f3dulos, controladores, servi\u00e7os e templates do AngularJS.   Este diret\u00f3rio cont\u00e9m:   assets  diret\u00f3rio onde s\u00e3o armazenados scripts css, fontes, imagens e bibliotecas front-end de \nterceiros;  src  diret\u00f3rio onde s\u00e3o armazenados os scripts de c\u00f3digo fonte javascript do seu projeto;  holder.js  script javascript que gera imagens placeholders, que podem ser utilizados em telas e \ninterfaces do seu projeto;  index.php  script php principal da aplica\u00e7\u00e3o. Ele \u00e9 o ponto de entrada da sua aplica\u00e7\u00e3o, nele a \nsua aplica\u00e7\u00e3o \u00e9 iniciada e todas as chamadas, AJAX ou convencionais passam por este script.", 
            "title": "Diret\u00f3rio web"
        }, 
        {
            "location": "/#arquivo-composerjson", 
            "text": "Arquivo que cont\u00e9m a rela\u00e7\u00e3o das depend\u00eancias das bibliotecas php do projeto.", 
            "title": "Arquivo composer.json"
        }, 
        {
            "location": "/#arquivo-phinxyml", 
            "text": "Como mencionado anteriormente, o projeto baseado no Singular utiliza o Phinx como gerenciador  de migrations do banco \nde dados da aplica\u00e7\u00e3o. O Phinx por sua vez, \u00e9 configurado atrav\u00e9s deste arquivo.", 
            "title": "Arquivo phinx.yml"
        }, 
        {
            "location": "/#arquivo-singular", 
            "text": "O Singular project utiliza o Singular Command para fornecer tarefas de linha de comando que automatizam a maioria \ndos processos repetitivos do desenvolvimento de um projeto. Mais adiante iremos ver em detalhes como utilizar essa \nferramenta e quais comandos est\u00e3o dispon\u00edveis para utiliza\u00e7\u00e3o.", 
            "title": "Arquivo singular"
        }, 
        {
            "location": "/#configuracao", 
            "text": "", 
            "title": "Configura\u00e7\u00e3o"
        }, 
        {
            "location": "/#configurando-o-virtual-host", 
            "text": "Para que seu projeto rode de forma simples na sua m\u00e1quina, \u00e9 necess\u00e1rio primeiramente configurar um virtual host no \nservidor web. Na Net On, utilizamos o  MAMP  em nosso ambiente de desenvolvimento, por isso, vamos \nver como configurar o virtual host para este ambiente.   A utiliza\u00e7\u00e3o do virtual host permitir\u00e1 que voc\u00ea realize seus testes durante o desenvolvimento de forma muito mais \nf\u00e1cil, ao inv\u00e9s de acessar no navegador um endere\u00e7o como  http://localhost/nomedoprojeto/web  podemos fazer algo do \ntipo  http://nomedoprojeto.local/", 
            "title": "Configurando o Virtual host"
        }, 
        {
            "location": "/#1-crie-uma-entrada-no-arquivo-hosts", 
            "text": "Pelo terminal da sua m\u00e1quina, abra o arquivo /etc/host  sudo vim /etc/hosts  Adicione a seguinte linha no arquivo, lembrando sempre de trocar o  nomedoprojeto  pelo nome do seu \nprojeto.  ...\n127.0.0.1 sng.local # trocar sng pelo nome do seu projeto\n...  Salve e feche o arquivo.", 
            "title": "1. Crie uma entrada no arquivo hosts"
        }, 
        {
            "location": "/#2-crie-o-arquivo-de-configuracao-do-virtual-host-no-mamp", 
            "text": "Abra o arquivo de configura\u00e7\u00f5es de virtual hosts pelo terminal:  sudo vim /Applications/MAMP/conf/apache/extra/httpd-vhosts.conf   E adicione o seguinte bloco de c\u00f3digo ao final do arquivo:  VirtualHost *:80 \n    DocumentRoot  /htdocs/sng/web  # trocar pelo caminho do diret\u00f3rio web completo do seu projeto\n    ServerName sng.local # trocar sng pelo nome do seu projeto /VirtualHost  Salve e feche o seu arquivo e, em seguida, reinicie o servi\u00e7o do apache do seu MAMP. Agora, dever\u00e1 ser poss\u00edvel \nacessar o projeto atrav\u00e9s do seu navegador web. Para isso basta digitar na barra de endere\u00e7os  http://sng.local/ . \nSe voc\u00ea se deparar com alguma mensagem de erro relacionado \u00e0 permiss\u00e3o em diret\u00f3rios, basta conceder as permiss\u00f5es \nde escrita no diret\u00f3rio e tentar novamente.   Agora voc\u00ea deve visualizar em seu navegador uma tela semelhante a esta: \nEntretanto, ainda n\u00e3o \u00e9 poss\u00edvel acessar o sistema nem mesmo come\u00e7ar a desenvolver seus pr\u00f3prios m\u00f3dulos. Para isso, \nprecisamos seguir com a configura\u00e7\u00e3o.", 
            "title": "2. Crie o arquivo de configura\u00e7\u00e3o do virtual host no MAMP"
        }, 
        {
            "location": "/#criando-o-banco-de-dados", 
            "text": "No seu SGBD, crie um novo banco de dados banco de dados com o nome definido para a base de dados do seu projeto.", 
            "title": "Criando o banco de dados"
        }, 
        {
            "location": "/#configurando-o-phinx", 
            "text": "Para gerenciar as migrations de banco de dados, o Singular Project utiliza o Phinx. Ele j\u00e1 est\u00e1 inclu\u00eddo no projeto \ncomo depend\u00eancia, no entanto, \u00e9 necess\u00e1rio configur\u00e1-lo.   Abra o arquivo  phinx.yml  localizado no diret\u00f3rio raiz do seu projeto e, em seguida:    Duplique o bloco de configura\u00e7\u00e3o  base  e altere o nome desse novo bloco para  dev-seunome  \nsubstitu\u00edndo o  seunome  pelo seu primeiro nome, sem acentua\u00e7\u00e3o e todo em min\u00fasculo.     No seu bloco de configura\u00e7\u00e3o, altere as configura\u00e7\u00f5es de endere\u00e7o da base de dados, senha, usu\u00e1rio e nome da base \nde dados;    O resultado final dever\u00e1 ser algo como:  ...\n dev-otavio:\n        adapter: mysql\n        host: localhost\n        name: sng\n        user: root\n        pass: 'root'\n        port: 3306\n        charset: utf8  Salve e feche o arquivo. Agora \u00e9 necess\u00e1rio configurar o ambiente padr\u00e3o de execu\u00e7\u00e3o do Phinx no seu ambiente. \nAbra o seu terminal e digite o seguinte c\u00f3digo:   export PHINX_ENVIRONMENT=dev-seunome # substituindo seunome pelo nome do bloco que voc\u00ea criou.  Finalmente, pelo terminal, dentro da pasta do seu projeto, execute o comando:  vendor/bin/phinx status  O resultado dever\u00e1 ser algo semelhante a:   Status  [Migration ID]  Started              Finished             Migration Name \n----------------------------------------------------------------------------------\n   down  20170630140758                                            CriaTabelaSingularAplicacao\n   down  20170630144050                                            CriaTabelaSingularModulo\n   down  20170701171751                                            InsereRegistrosIniciaisSingular\n   down  20170701173743                                            CriaTabelaSingularPerfil\n   down  20170701174500                                            CriaTabelaSingularComponente\n   down  20170701175748                                            CriaTabelaSingularPermissao\n   down  20170703224706                                            CriaTabelaSingularUsuario\n   down  20170827183316                                            InsereRegistroPerfilUsuario\n   down  20170918230051                                            InsereRegistroModuloUsuario\n   down  20171002180438                                            InsereRegistroModuloComponente\n   down  20171004103414                                            InsereRegistrosComponentes1507124054\n   down  20171006084220                                            InsereRegistrosComponentes1507290140  Por hora, \u00e9 o suficiente, ainda n\u00e3o iremos executar as migrations.", 
            "title": "Configurando o PHINX"
        }, 
        {
            "location": "/#configurando-o-banco-de-dados", 
            "text": "Crie uma c\u00f3pia do arquivo  app/config/database.json  e a nomeie de  app/config/local.json  dentro do mesmo diret\u00f3rio. \nAgora, altere as configura\u00e7\u00f5es do banco de dados neste arquivo de acordo com seu ambiente e adicione a propriedade  priority  com o valor 100. O resultado final ser\u00e1 semelhante a:  {\n   _priority : 100,\n   db.driver :  mysql ,\n   db.name :  sng , \n   db.host :  localhost ,\n   db.user :  root ,\n   db.pass :  root ,\n   db.charset :  utf8 ,\n   db.collation :  utf8_unicode_ci \n}", 
            "title": "Configurando o banco de dados"
        }, 
        {
            "location": "/#inicializando-a-aplicacao", 
            "text": "Pronto, agora, todo o ambiente est\u00e1 pronto para iniciar o desenvolvimento, vamos ent\u00e3o executar nossas migrations e \ncome\u00e7ar a trabalhar. Para isso, no terminal, digite:  vendor/bin/phinx migrate  Se tudo correu bem, o resultado ser\u00e1 parecido com:  neton-alpha:sng oaugustus$ vendor/bin/phinx migrate\nPhinx by Rob Morgan - https://phinx.org. 0.8.1\n\nusing config file ./phinx.yml\nusing config parser yaml\nusing migration paths \n - /htdocs/sng/db/migrations\nusing seed paths \nwarning no environment specified, defaulting to: dev-otavio\nusing adapter mysql\nusing database sng\n\n == 20170630140758 CriaTabelaSingularAplicacao: migrating\n == 20170630140758 CriaTabelaSingularAplicacao: migrated 0.0215s\n\n == 20170630144050 CriaTabelaSingularModulo: migrating\n == 20170630144050 CriaTabelaSingularModulo: migrated 0.0217s\n\n == 20170701171751 InsereRegistrosIniciaisSingular: migrating\n == 20170701171751 InsereRegistrosIniciaisSingular: migrated 0.0053s\n\n == 20170701173743 CriaTabelaSingularPerfil: migrating\n == 20170701173743 CriaTabelaSingularPerfil: migrated 0.0196s\n\n == 20170701174500 CriaTabelaSingularComponente: migrating\n == 20170701174500 CriaTabelaSingularComponente: migrated 0.0180s\n\n == 20170701175748 CriaTabelaSingularPermissao: migrating\n == 20170701175748 CriaTabelaSingularPermissao: migrated 0.0169s\n\n == 20170703224706 CriaTabelaSingularUsuario: migrating\n == 20170703224706 CriaTabelaSingularUsuario: migrated 0.0212s\n\n == 20170827183316 InsereRegistroPerfilUsuario: migrating\n == 20170827183316 InsereRegistroPerfilUsuario: migrated 0.0049s\n\n == 20170918230051 InsereRegistroModuloUsuario: migrating\n == 20170918230051 InsereRegistroModuloUsuario: migrated 0.0032s\n\n == 20171002180438 InsereRegistroModuloComponente: migrating\n == 20171002180438 InsereRegistroModuloComponente: migrated 0.0023s\n\n == 20171004103414 InsereRegistrosComponentes1507124054: migrating\n == 20171004103414 InsereRegistrosComponentes1507124054: migrated 0.0034s\n\n == 20171006084220 InsereRegistrosComponentes1507290140: migrating\n == 20171006084220 InsereRegistrosComponentes1507290140: migrated 0.0047s\n\nAll Done. Took 0.1754s  Ainda no terminal, digite o comando:  ./singular component:grant-full-access 1  E a mensagem:  Acesso garantido para o perfil 1!  Ir\u00e1 aparecer. Agora, podemos acessar nosso novo sistema. Acesse a tela de login pelo endere\u00e7o  http://nomeprojeto.local/  \ne digite o usu\u00e1rio e senha de acesso:   Login : singular  Senha : singular   Voc\u00ea ser\u00e1 autenticado no sistema e redirecionado para o acesso restrito. A interface agora ser\u00e1 a seguinte:     Perfeito! Agora podemos come\u00e7ar a codificar nosso novo sistema. No restante da documenta\u00e7\u00e3o iremos aprender a criar \nm\u00f3dulos, adicionar funcionalidades, restringir o acesso de perfis de usu\u00e1rio, e a utilizar as classes utilit\u00e1rias para \nagilizar nosso servi\u00e7o de desenvolvimento.", 
            "title": "Inicializando a aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/conceitos/", 
            "text": "O Singular Framework, foi projetado para ser um framework Ajax, ou seja, \u00e0 exce\u00e7\u00e3o das views principais (autentica\u00e7\u00e3o e \nacesso seguro, al\u00e9m das que se fizerem necess\u00e1rias), todo o front-end \u00e9 codificado em HTML, CSS e JavaScript, com apoio \ndo framework AngularJS. Sempre que \u00e9 necess\u00e1rio um dado que venha do servidor (backend) \u00e9 feita uma requisi\u00e7\u00e3o \nass\u00edncrona Ajax para uma classe em PHP, que por sua vez, ap\u00f3s realizar o processamento necess\u00e1rio, retorna a resposta \npara o frontend no formato JSON.\n\n\nPor este motivo, todo o ciclo de desenvolvimento se divide basicamente em dois ambientes: Backend e Frontend.\n\n\nBackend\n#\n\n\nNo backend \u00e9 onde s\u00e3o feitos todos os processamentos de l\u00f3gica de neg\u00f3cio, acesso \u00e0 base de dados, gera\u00e7\u00e3o de relat\u00f3rios, \nenvios de email, e outras tarefas semelhantes. Como mencionado anteriormente, o Singular Framework foi constru\u00eddo sobre \no Silex, mas de forma totalmente orientada a objetos. \n\n\nTodo o c\u00f3digo backend de um projeto no Singular reside dentro do diret\u00f3rio \nsrc\n. \n\n\n\n\nSingular CLI\n#\n\n\nUm projeto criado com o Singular Project inclui o \nSingular Command Line Interface\n. O \nSingular\nCli\n \u00e9 uma ferramenta utilit\u00e1ria que automatiza muitas tarefas no processo de desenvolvimento de aplica\u00e7\u00f5es.\n\n\nExibindo os comandos dispon\u00edveis\n#\n\n\nPara visualizar os comandos dispon\u00edveis no \nSingular Cli\n, na raiz do seu projeto, execute o comando:\n\n\n./singular \n\n\n\n\nO resultado ser\u00e1 algo como:\n\n\nAvailable commands:\n  help                         Displays help for a command\n  list                         Lists commands\n backend\n  backend:create-command       Cria um novo comando num pacote\n  backend:create-controller    Cria um novo controlador num pacote\n  backend:create-pack          Cria e habilita um novo pacote na aplica\u00e7\u00e3o\n  backend:create-service       Cria um novo servi\u00e7o num pacote\n  backend:create-store         Cria um novo store num pacote\n  backend:disable-pack         Desabilita um pacote da aplica\u00e7\u00e3o\n  backend:enable-pack          Habilita um pacote da aplica\u00e7\u00e3o\ncomponent\n  component:create-migration   Cria migrations para inclus\u00e3o dos componentes no banco de dados\n  component:grant-full-access  Concede permiss\u00e3o de acesso a todos os componentes para um perfil\n frontend\n  frontend:create-controller   Cria um controlador de frontend na aplica\u00e7\u00e3o\n  frontend:create-module       Cria um m\u00f3dulo de frontend na aplica\u00e7\u00e3o\n  frontend:create-store        Cria um store de frontend na aplica\u00e7\u00e3o\n  frontend:create-view         Cria uma view de frontend para um m\u00f3dulo na aplica\u00e7\u00e3o\n lint\n  lint:yaml                    Lints a file and outputs encountered errors\n sessao\n  sessao:cria-perfil           Cria um novo registro de perfil na aplica\u00e7\u00e3o\n\n\n\n\n\n\nPacote\n#\n\n\nCada conjunto de funcionalidades \u00e9 organizado dentro de um pacote no diret\u00f3rio src. Por exemplo, se o sistema a ser \ndesenvolvido possui um conjunto de funcionalidades de cadastro, poder\u00e1 ser criado um pacote \nCadastro\n \nque ir\u00e1 armazenar todas as classes relacionadas \u00e0 funcionalidade de cadastro. Quando um novo projeto \u00e9 criado com o \nSingular Project, j\u00e1 existe um pacote chamado \nSessao\n.\n\n\nEstrutura de um Pacote\n#\n\n\nComo dito anteriormente, um pacote \u00e9 uma forma de agrupar um conjunto de funcionalidades relacionadas. \nQuando um pacote \u00e9 criado, a seguinte estrutura de diret\u00f3rios e arquivos \u00e9 criada na raiz do diret\u00f3rio \nsrc\n:\n\n\n\n\nCommand\n: Diret\u00f3rio onde s\u00e3o armazenadas as classes das tarefas que ser\u00e3o adicionadas \u00e0 linha de comando do singular para o pacote em quest\u00e3o;\n\n\nController\n: Diret\u00f3rio onde s\u00e3o armazenadas as classes dos controladores, controladores s\u00e3o o canal de comunica\u00e7\u00e3o entre o frontend e o backend. Funcionam como uma API do backend disponibilizada para acesso no frontend;\n\n\nService\n: Diret\u00f3rio onde s\u00e3o armazenadas classes auxiliares que disponibilizam servi\u00e7os para que o container de servi\u00e7os do Silex possa disponibilizar para toda a aplica\u00e7\u00e3o;\n\n\nStore\n: Diret\u00f3rio onde s\u00e3o armazenadas as classes que intermediam a comunica\u00e7\u00e3o da aplica\u00e7\u00e3o com o banco de dados. Cada tabela \u00e9 representada no Singular por um store;\n\n\nPacoteServiceProvider.php\n: Arquivo de defini\u00e7\u00e3o do pacote, ele \u00e9 que registra o provedor de servi\u00e7os do pacote e o exp\u00f5e para o container de servi\u00e7os da aplica\u00e7\u00e3o.\n\n\n\n\nO Singular CLI possui tarefas utilit\u00e1rias para a cria\u00e7\u00e3o de todos os recursos de um pacote, mais adiante iremos estud\u00e1-lo para conhecer as tarefas dispon\u00edveis.\n\n\nCriando um pacote\n#\n\n\nA maneira mais f\u00e1cil de criar um pacote \u00e9 utilizar o Singular CLI, para isso, no terminal, no diret\u00f3rio raiz do seu projeto digite o seguinte comando:\n\n\n./singular backend:create-pack NomeDoPacote\n\n\n\n\nOnde, \nNomeDoPacote\n, dever\u00e1 ser substitu\u00eddo pelo nome do pacote que voc\u00ea deseja criar.\n\n\nAo executar este comando, um novo diret\u00f3rio nomeado de acordo com nome que voc\u00ea forneceu ao pacote ser\u00e1 criado na \nraiz do diret\u00f3rio src, com a estrutura completa de um pacote.\n\n\nAl\u00e9m disso, um arquivo chamado \nnomedopacote.php\n \u00e9 criado dentro do diret\u00f3rio \napp/packs\n. Ao abrir \neste arquivo, voc\u00ea pode verificar a seguinte declara\u00e7\u00e3o:\n\n\nuse NomeDoPacote\\NomeDoPacoteServiceProvider;\n\n$app-\nregister(new NomeDoPacoteServiceProvider());\n\n\n\n\nUma vez que o Singular \u00e9 criado sobre o \nSilex Framework\n, ele tamb\u00e9m utiliza a funcionalidade de provedores\nde servi\u00e7o para extender suas funcionalidades. Neste caso, cada novo pacote criado \u00e9 um novo provedor de servi\u00e7os, e \ncada funcionalidade desse pacote extende as funcionalidades do framework.\n\n\nDesabilitando um pacote\n#\n\n\nAlgumas vezes, pode ser necess\u00e1rio, para efeitos de testes ou por outro motivo, desativar um pacote e todas as suas \nfuncionalidades. Para fazer isso, basta apagar o arquivo \napp/packs/nomedopacote.php\n. Mas isso pode ser feito via \n\nSingular Cli\n\n\n./singular backend:disable-pack NomeDoPacote\n\n\n\n\nHabilitando um pacote\n#\n\n\nSe um pacote foi desabilitado, ou criado manualmente, para que o mesmo seja novamente ativado, \u00e9 necess\u00e1rio que ele seja\nhabilitado. Para isso, basta criar um arquivo chamado \nnomedopacote.php\n dentro do diret\u00f3rio \napp/packs\n. \nDentro desse arquivo, voc\u00ea deve registrar o seu provedor de servi\u00e7os.\n\n\nuse NomeDoPacote\\NomeDoPacoteServiceProvider;\n\n$app-\nregister(new NomeDoPacoteServiceProvider());\n\n\n\n\nEntretanto, isso tamb\u00e9m pode ser alcan\u00e7ado de forma muito mais simples, atrav\u00e9s do \nSingular Cli\n\n\n./singular backend:enable-pack NomeDoPacote\n\n\n\n\n\n\nComando\n#\n\n\nComandos s\u00e3o tarefas que podem ser executadas pelo terminal atrav\u00e9s do Singular Cli. Comandos s\u00e3o \u00fateis para disparar \nemails, executar tarefas de limpeza de tabelas, etc. Eles podem ser acionados manualmente, ou ser programados para \nexecutar automaticamente atrav\u00e9s de ferramentas como o \ncron\n do linux.\n\n\nCriando um comando\n#\n\n\nCada pacote pode definir seus pr\u00f3prios comandos, e desta forma extender as funcionalidades do \nSingular Cli\n\npara executar tarefas espec\u00edficas do pacote. \n\n\nPara criar um comando, basta digitar a seguinte instru\u00e7\u00e3o no seu terminal:\n\n\n./singular backend:create-command Comando Pacote\n\n\n\n\n\n\nOnde\n\n\nComando\n deve ser substitu\u00eddo pelo nome script de comando\n\n\nPacote\n deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo comando\n\n\n\n\nAo executar essa instru\u00e7\u00e3o, uma nova classe php, com o nome fornecido para o comando, ser\u00e1 criado no diret\u00f3rio Command \ndo seu pacote. \n\n\nA estrutura dessa classe \u00e9 bem simples, ela possui apenas 2 m\u00e9todos \nconfigure\n e \nexecute\n, \nconforme veremos em detalhe abaixo:\n\n\n 1.  class TesteCommandCommand extends Command\n 2.  {\n 6.      public function configure()\n 7.      {\n 8.         $this-\nsetName('sessao:teste-command')\n 9.             -\nsetDescription('Descri\u00e7\u00e3o do comando')\n10.            -\nsetHelp('Ajuda para execu\u00e7\u00e3o do comando')\n11.            -\naddArgument(\n12.                'parametro',\n13.                InputArgument::REQUIRED,\n14.                'Descricao do par\u00e2metro'\n15.            );\n16.      }\n17.\n24.      public function execute(InputInterface $input, OutputInterface $output)\n25.      {\n26.          $app = $this-\ngetSilexApplication();\n27.\n28.          $output-\nwriteln(sprintf('\ninfo\n%s\n/info\n', 'Comando executado com sucesso!'));\n29.      }\n30.  }\n\n\n\n\nNo m\u00e9todo \nconfigure\n \u00e9 feita a configura\u00e7\u00e3o do par\u00e2metro: \n\n\n\n\nEntendendo\n\n\nLinha 8\n \u00c9 definido o nome do comando que ser\u00e1 exibido no Singular Cli, \n\u00e9 uma boa pr\u00e1tica utilizar o nome do pacote como namespace de um comando \nPor exemplo, se o comando chama-se teste o pacote cadastro, o nome deveria ser \ncadastro:teste\n\n\nLinha 9\n \u00c9 definido o texto de defini\u00e7\u00e3o do comando, que exibe a ajuda ao usu\u00e1rio, sobre o que o \ncomando faz\n\n\nLinha 10\n \u00c9 definido um texto de ajuda, que ser\u00e1 exibido quando o usu\u00e1rio digitar a op\u00e7\u00e3o de ajuda \npara o seu comando\n\n\nLinha 11 a 14\n S\u00e3o definidos os argumentos do comando, ou par\u00e2metros, como costumamos cham\u00e1-los. \nPodem ser criados tantos argumentos quanto necess\u00e1rios. Argumentos s\u00e3o obrigat\u00f3rios, mas existe op\u00e7\u00f5es, que s\u00e3o \npar\u00e2metros opcionais \n\n\n\n\nO m\u00e9todo \nexecute\n \u00e9 acionado quando o seu comando \u00e9 executado pelo Singular Cli, ele pode acessar \nqualquer servi\u00e7o da sua aplica\u00e7\u00e3o para executar uma determinada tarefas. \n\n\nPara maiores informa\u00e7\u00f5es, acesse o site da documenta\u00e7\u00e3o do \nComponente Console do Symfony\n.\n\n\nCriando um controlador\n#\n\n\nControladores s\u00e3o a interface de integra\u00e7\u00e3o e comunica\u00e7\u00e3o entre o frontend e o backend. Quando uma informa\u00e7\u00e3o do backend \u00e9 necess\u00e1ria no frontend, como por exemplo, uma lista de usu\u00e1rios, uma requisi\u00e7\u00e3o \u00e9 feita a partir da interface para um controlador, esse por sua vez, \u00e9 respons\u00e1vel por realizar as chamadas aos servi\u00e7os e stores e retornar essa informa\u00e7\u00e3o para o frontend no formato json. \n\n\nPara criar um novo controlador atrav\u00e9s do Singular Cli, basta executar o seguinte c\u00f3digo:\n\n\n./singular backend:create-controller Controlador Pacote\n\n\n\n\nOnde:\n+ \nControlador\n: deve ser substitu\u00eddo pelo nome do controlador;\n+ \nPacote\n: deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo controlador;\n\n\nAo executar essa instru\u00e7\u00e3o, uma nova classe php, com o nome fornecido para o controlador, ser\u00e1 criado no diret\u00f3rio Controller do seu pacote.  A estrutura b\u00e1sica da classe de um controlador se parece com:\n\n\n/**\n * Classe Perfil\n *\n * @Controller\n *\n * @author Ot\u00e1vio Fernandes \notavio@netonsolucoes.com.br\n\n */\nclass Perfil extends SingularController\n{\n    use Crud;\n\n    /**\n     * Defina o store padr\u00e3o do controlador.\n     *\n     * @var $store\n     */\n    protected $store = 'perfil';\n}\n\n\n\n\nO que diferencia uma classe de um controlador de uma classe qualquer \u00e9 a anota\u00e7\u00e3o \n@Controller\n no bloco de documenta\u00e7\u00e3o da classe. Se essa anota\u00e7\u00e3o n\u00e3o existir, n\u00e3o ser\u00e1 poss\u00edvel acessar nenhum de seus m\u00e9todos atrav\u00e9s do frontend.\n\n\nOutro ponto importante, \u00e9 que, se voc\u00ea desejar que o controlador criado j\u00e1 implemente m\u00e9todos b\u00e1sicos de funcionalidade \nCRUD\n, voc\u00ea pode utilizar o \nTrait\n \nCrud\n, como \u00e9 feito na linha \nuse Crud\n. Por padr\u00e3o, um controlador criado pelo Singular Cli, j\u00e1 implementa esse tra\u00e7o. Os m\u00e9todos disponibilizados pelo tra\u00e7o Crud s\u00e3o:\n\n\n\n\n\n\nfind\n: Fun\u00e7\u00e3o que recupera uma lista de registros vinculados h\u00e1 um store de acordo com par\u00e2metros de filtro, pagina\u00e7\u00e3o e ordena\u00e7\u00e3o (\nfilter\n, \npaging\n e \nsort\n);\n\n\n\n\n\n\nget\n: Fun\u00e7\u00e3o que recupera um registro espec\u00edfico vinculado h\u00e1 um store de acordo com o par\u00e2metro \nid\n desse registro;\n\n\n\n\n\n\nsave\n: Fun\u00e7\u00e3o que cria/atualiza um registro espec\u00edfico vinculado h\u00e1 um store de acordo com par\u00e2metros de campos de uma tabela. Se o campo \nid\n for enviado na lista de par\u00e2metros o registro \u00e9 atualizado, caso contr\u00e1rio, um novo registro \u00e9 criado e o seu \nid\n \u00e9 retornado para o m\u00e9todo que fez a requisi\u00e7\u00e3o no frontend;\n\n\n\n\n\n\nremove\n: Fun\u00e7\u00e3o que exclui um registro vinculado h\u00e1 um store atrav\u00e9s do seu \nid\n informado como par\u00e2metro.\n\n\n\n\n\n\nOutro ponto muito importante a considerar \u00e9 a propriedade \n$store\n da classe do controlador. Essa propriedade faz refer\u00eancia direta a qual classe \nstore\n o controlador est\u00e1 vinculado. Sem essa propriedade definida, nenhum m\u00e9todo definido pelo tra\u00e7o \nCrud\n ir\u00e1 funcionar. Ela deve referenciar, no min\u00fasculo, h\u00e1 uma classe store, criada no mesmo pacote do controlador. Caso n\u00e3o seja um controlador que use o tra\u00e7o Crud, ela n\u00e3o \u00e9 necess\u00e1ria. \n\n\nExpondo m\u00e9todos para o frontend\n#\n\n\nComo o objetivo de uma classe de controlador \u00e9 fornecer um m\u00e9todo de comunica\u00e7\u00e3o entre o backend e o frontend, \u00e9 extremamente necess\u00e1rio que os m\u00e9todos criados no controlador sejam \"expostos\" para o frontend. Veja como um novo m\u00e9todo pode ser criado e exposto para o frontend:\n\n\n?php\nnamespace Sessao\\Controller;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Singular\\SingularController;\nuse Singular\\Crud;\nuse Singular\\Annotation\\Controller;\nuse Singular\\Annotation\\Route;\nuse Singular\\Annotation\\Direct;\nuse Singular\\Annotation\\Value;\nuse Singular\\Annotation\\Assert;\nuse Singular\\Annotation\\Convert;\nuse Singular\\Annotation\\After;\nuse Singular\\Annotation\\Before;\n\n/**\n * Classe Perfil\n *\n * @Controller\n *\n * @author Ot\u00e1vio Fernandes \notavio@netonsolucoes.com.br\n\n */\nclass Perfil extends SingularController\n{\n    use Crud;\n\n    /**\n     * Defina o store padr\u00e3o do controlador.\n     *\n     * @var $store\n     */\n    protected $store = 'perfil';\n\n    /**\n     * Emite uma sauda\u00e7\u00e3o para um nome completo.\n     *\n     * @Route(method=\npost\n)\n     *\n     * @param Request $request\n     *\n     * @return \\Singular\\Response\\JsonResponse\n     */\n    public function saudacoesNomeCompleto(Request $request)\n    {\n        $app = $this-\napp;\n\n        $primeiroNome = $request-\nget('primeiro_nome');\n        $segundoNome = $request-\nget('segundo_nome');\n\n        return $app-\njson([\n            'mensagem' =\n 'Ol\u00e1 '.$primeiroNome.' '.$segundoNome.', seja bem vindo!'\n        ]);\n    }\n}\n\n\n\n\nO m\u00e9todo \nsaudacoesNomeCompleto\n do controlador \nPerfil\n do pacote \nSessao\n precisa ser exposto para a camada de frontend. Para isso, utilizamos a anota\u00e7\u00e3o \n\n\n@Route(method=\npost\n)\n\n\n\n\nAo utilizarmos essa anota\u00e7\u00e3o, estamos tornando poss\u00edvel que uma requisi\u00e7\u00e3o seja feita diretamente da interface por exemplo atrav\u00e9s do servi\u00e7o \n$http\n:\n\n\n$http.post('./sessao/perfil/saudacoesNomeCompleto', {primeiro_nome: \nOtavio\n, segundo_nome: \nFernandes\n}, function(response){\n   alert(response.mensagem);\n});\n\n\n\n\nTodos os m\u00e9todos http est\u00e3o dispon\u00edveis para serem utilizados na anota\u00e7\u00e3o \n@Route\n (get, post, put, delete, options). Algumas vezes, pode ser necess\u00e1rio expor uma fun\u00e7\u00e3o do controlador para mais de um m\u00e9todo http, isso pode ser facilmente alcan\u00e7ado com:\n\n\n@Route(methods={\npost\n,\noptions\n})\n\n\n\n\nPor padr\u00e3o, todos os par\u00e2metros s\u00e3o recuperados na fun\u00e7\u00e3o do controlador atrav\u00e9s de um objeto da classe Request que \u00e9 par\u00e2metro da fun\u00e7\u00e3o. Entretanto, algumas vezes, voc\u00ea pode necessitar passar alguns par\u00e2metros na pr\u00f3pria URL, para isso basta adicionar o nome desses par\u00e2metros na sua fun\u00e7\u00e3o:\n\n\n    /**\n     * Emite uma sauda\u00e7\u00e3o para um nome completo.\n     *\n     * @Route(method=\nget\n)\n     *\n     * @param Request $request\n     * @param string  $primeiroNome\n     * @param string  $segundoNome\n     *\n     * @return \\Singular\\Response\\JsonResponse\n     */\n    public function saudacoesNomeCompleto(Request $request, $primeiroNome, $segundoNome)\n    {\n        $app = $this-\napp;\n\n        $primeiroNome = $primeiroNome;\n        $segundoNome = $segundoNome;\n\n        return $app-\njson([\n            'mensagem' =\n 'Ol\u00e1 '.$primeiroNome.' '.$segundoNome.', seja bem vindo!'\n        ]);\n    }\n\n\n\n\nE a chamada http ficaria semelhante \u00e0:\n\n\n$http.get('./sessao/perfil/saudacoesNomeCompleto/Otavio/Fernandes', function(response){\n   alert(response.mensagem);\n});\n\n````\n### Criando um Servi\u00e7o\n\nServi\u00e7os s\u00e3o classes que exp\u00f5e m\u00e9todos e fun\u00e7\u00f5es utilit\u00e1rias que permitem a execu\u00e7\u00e3o de algumas l\u00f3gicas e regras de neg\u00f3cio para outras partes da aplica\u00e7\u00e3o (outros servi\u00e7os e controladores). \n\nPara criar um servi\u00e7o, basta utilizar o Singular Cli:\n\n```shell\n./singular backend:create-service NomeServico Pacote\n\n\n\n\nOnde: \n+ \nNomeServico\n: deve ser substitu\u00eddo pelo nome do servi\u00e7o que se deseja criar;\n+ \nPacote\n: deve ser substitu\u00eddo pelo nome do pacote onde se deseja criar o novo servi\u00e7o;\n\n\nTodo servi\u00e7o tem acesso ao container da aplica\u00e7\u00e3o, que pode ser acessado atrav\u00e9s da propriedade $app da aplica\u00e7\u00e3o. Pelo container da aplica\u00e7\u00e3o, voc\u00ea pode acessar qualquer outro servi\u00e7o definido na aplica\u00e7\u00e3o. \n\n\nAssim como com os controladores, um servi\u00e7o no Singular Framework precisa ser anotado para estar registrado no container da aplica\u00e7\u00e3o como um servi\u00e7o. Para isso, a anota\u00e7\u00e3o \n@Service\n deve ser utilizada. \n\n\nAcessando servi\u00e7os do container\n#\n\n\nFrequentemente, faz-se necess\u00e1rio acessar servi\u00e7os a partir de um controlador, ou mesmo de outro servi\u00e7o. Entende-se por servi\u00e7o, qualquer classe que estiver dentro de um pacote da aplica\u00e7\u00e3o. Suponha que voc\u00ea precise acessar um servi\u00e7o chamado \nCalculoSalario\n que est\u00e1 definido dentro do pacote \nFinanceiro\n, para acess\u00e1-lo, basta pegar uma refer\u00eancia do container de servi\u00e7os da aplica\u00e7\u00e3o, como \u00e9 feito no pimple:\n\n\n$servico = $this-\napp['cadastro.store.calculo_salario'];\n\n\n\n\n\u00c9 poss\u00edvel acessar qualquer servi\u00e7o criado, a partir de qualquer pacote, controlador ou servi\u00e7o, simplesmente usando a anota\u00e7\u00e3o de namespace de servi\u00e7os com tr\u00eas partes. Onde a primeira parte identifica o pacote, a segunda, o diret\u00f3rio do pacote (Command, Controller, Service, Store) e a terceira o nome da classe em min\u00fasculo.\n\n\nCriando um Store\n#\n\n\nClasses Stores s\u00e3o a camada de acesso ao banco de dados da sua aplica\u00e7\u00e3o. Cada store, pode representar uma tabela, e disponibiliza uma API de m\u00e9todos que estar\u00e3o dispon\u00edveis para servi\u00e7os e controladores que executam consultas e manipula\u00e7\u00f5es espec\u00edficas no banco de dados retornando resultados, alterando ou manipulando registros.\n\n\nPara criar um store, voc\u00ea pode utilizar o Singular Cli:\n\n\n./singular backend:create-store Store Pacote tabela\n\n\n\n\n\n\nStore\n: deve ser substitu\u00eddo pelo nome da classe do store;\n\n\nPacote\n: deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo controlador;\n\n\ntabela\n: nome da tabela no banco de dados vinculada ao store;\n\n\n\n\nM\u00e9todos CRUD herdados da classe SingularStore\n#\n\n\nUma classe store faz heran\u00e7a da classe \nSingular\\SingularStore\n, ent\u00e3o ela herda alguns m\u00e9todos utilit\u00e1rios do tipo crud padr\u00e3o dessa classe:\n\n\n\n\nfind($id: integer):array\n: Retorna um registro de uma tabela do banco de dados pelo seu id. Recebe o \nid\n do registro como par\u00e2metro e retorna um array representando um registro \u00fanico da tabela.\n\n\n\n\n$usuario = $app['cadastro.store.usuario']-\nfind(1);\n\n\n\n\n\n\nfindOneBy($filters: array):array\n: Retorna um registro de uma tabela atrav\u00e9s de um array de filtros aplicados nessa tabela. Recebe um array de filtros como par\u00e2metro e retorna um array representando um registro \u00fanico da tabela.\n\n\n\n\n$usuario = $app['cadastro.store.usuario']-\nfindBy([\n      'login' =\n '%:Otavio', \n      'email' =\n 'otavio@neton.com.br'\n]);\n\n\n\n\n\n\nfindBy($filters: array, $pageOpts: array, $sort: array)\n: Retorna um conjunto de registros que combinam com um grupo de filtros aplicado na tabela. Recebe um array de filtros como par\u00e2metro, e tamb\u00e9m pode receber par\u00e2metros de pagina\u00e7\u00e3o e ordena\u00e7\u00e3o dos resultados e retorna um array contendo um conjunto de resultados que combinam com os filtros aplicados;\n\n\n\n\n$usuarios = $app['cadastro.store.usuario']-\nfindBy(\n     ['email' =\n '%:gmail.com'],\n     ['start' =\n 0,'limit'=\n 5], \n     ['nome' =\n 'asc']\n);\n\n\n\n\n\n\nsave($record:array):integer\n: Cria/atualiza um registro na tabela e retorna o seu id;\n\n\n\n\n$usuario = ['nome' =\n 'Ot\u00e1vio', 'login' =\n 'otavio', 'senha'=\n '123];\n$id = $app['cadastro.store.usuario']-\nsave($usuario);\n\n\n\n\n\n\nremove($id: integer): boolean\n: Remove um registro da tabela atrav\u00e9s do seu id e retorna o booleano do sucesso da opera\u00e7\u00e3o;\n\n\n\n\n$excluido = $app['cadastro.store.usuario']-\nremove(1);\n\n\n\n\n\n\nremoveBy($filter: array)\n: boolean: Remove um ou mais registros da tabela atrav\u00e9s da combina\u00e7\u00e3o de filtros aplicados na tabela;\n\n\n\n\n$excluido = $app['cadastro.store.usuario']-\nremoveBy(['email' =\n '%:gmail.com']);\n\n\n\n\nPerfis de consulta\n#\n\n\nTodas as fun\u00e7\u00f5es de consulta herdadas do SingularStore, por padr\u00e3o, retornam determinados campos, aplicando joins, groupings e filtros padr\u00e3o. Isso \u00e9 \u00f3timo, pois evita a cria\u00e7\u00e3o de consultas complexas desnecess\u00e1rias agilizando o processo. Entretanto, pode haver a necessidade de trazer informa\u00e7\u00f5es diferentes, com filtros e joins diferentes, dependendo do contexto. A vers\u00e3o 2 do Singular implementa uma funcionalidade chamada \nPerfis de consulta (profiles)\n que permite criar v\u00e1rios perfis de consulta (campos do select, filtros, joins, groupings), dessa forma \u00e9 poss\u00edvel de acordo com o contexto, selecionar um ou outro perfil padr\u00e3o, eliminando ainda mais a necessidade de criar querys complexas para atividades triviais.\n\n\nQuando voc\u00ea cria um novo store, por padr\u00e3o ele j\u00e1 define o padr\u00e3o \ndefault\n de consulta:\n\n\n    ...\n    /**\n     * Perfis de consulta.\n     *\n     * @var array\n     */\n    protected $profiles = [\n        'default' =\n [\n            'select' =\n ['t.*'],\n            'joins' =\n [],\n            'filters' =\n [],\n            'groupings' =\n []\n        ]\n    ];\n    ...\n\n\n\n\nUm perfil de consulta nada mais \u00e9 que um array de arrays estruturados. Para criar um novo perfil, basta criar um elemento na propriedade $profiles atribuindo-lhe um nome e igualando seu valor a um outro array com as propriedades:\n+ \nselect\n: array com a lista dos campos que ser\u00e3o selecionadas, por padr\u00e3o o alias da tabela vinculada ao store \u00e9 \nt\n;\n\n\n[\n   'select'=\n ['t.nome','t.id as codigo']\n]\n````\n+ __joins__: um array de defini\u00e7\u00e3o de um relacionamento com outra tabela. Para cada elemento do join o primeiro par\u00e2metro \u00e9 o nome da tabela relacionada, o segundo o alias, o terceiro a condi\u00e7\u00e3o de igualdade do relacionamento e o quarto e opcional, o tipo de relacionamento (left ou join), se for omitido assume o valor 'join'.\n```php\n[\n   'joins' =\n [\n      ['perfil','p','p.id = u.perfil_id', 'left']\n   ]\n]\n\n\n\n\n\n\nfilters\n: um array de defini\u00e7\u00e3o dos filtros padr\u00e3o a serem aplicados na consulta.\n\n\n\n\n[\n   'filters' =\n [\n      'ativo' =\n '1'\n   ]\n]\n\n\n\n\n\n\ngroupings\n: um array de defini\u00e7\u00e3o dos agrupamentos padr\u00e3o aplicados na consulta\n\n\n\n\n[\n   'grouping' =\n [\n      't.id'\n   ]\n]\n\n\n\n\nPara criar um novo perfil de consulta, apenas crie um novo elemento no array $profiles e defina os valores que julgar necess\u00e1rios. Para selecionar um perfil de consulta, basta acionar o m\u00e9todo \nsetProfile\n antes de executar uma fun\u00e7\u00e3o como (find, findBy, findOneBy).\n\n\n$app['cadastro.store.usuario']-\nsetProfile('perfil')-\nfindBy(['id' =\n '\n:10']);\n\n\n\n\nCriando consultas customizadas\n#\n\n\nEmbora os m\u00e9todos findBy e findOneBy possam ser muito \u00fateis e flex\u00edveis atrav\u00e9s da utiliza\u00e7\u00e3o dos perfis de consulta, algumas vezes se faz necess\u00e1rio criar consultas customizadas e complexas para realizar tarefas espec\u00edficas. Esses m\u00e9todos podem ser facilmente criados nas classes store. \n\n\nA classe store, possui uma propriedade \n$db\n que fornece acesso \u00e0 classe de conex\u00e3o \nDBAL\n do Doctrine para o Silex. Para facilitar a cria\u00e7\u00e3o de consultas, e ter consultas que sejam mais leg\u00edveis, \u00e9 extremamente importante utilizar o \nQueryBuilder\n do Doctrine. Para recuperar uma nova inst\u00e2ncia do query builder, basta:\n\n\n$qb = $this-\ndb-\ncreateQueryBuilder();\n\n\n\n\nAo criar uma consulta customizada, geralmente, precisamos passar filtros para essa consulta. Por quest\u00f5es de seguran\u00e7a, \nSEMPRE\n utilize a vincula\u00e7\u00e3o de par\u00e2metros para definir filtros. \nN\u00c3O UTILIZE\n a vincula\u00e7\u00e3o da entrada do usu\u00e1rio diretamente na montagem da sua consulta. Vamos ver uma aplica\u00e7\u00e3o de certo e errado:\n\n\n/* ERRADO */\n$qb-\nselect('u.*')\n   -\nfrom('usuarios','u')\n   -\nwhere('u.idade \n '.$idade);\n$rs = $this-\ndb-\nfetchAll($qb-\ngetSQL());\n\n/* CORRETO */\n$qb-\nselect('u.*')\n   -\nfrom('usuarios','u')\n   -\nwhere('u.idade \n :idade');\n\n$rs = $this-\ndb-\nfetchAll($qb-\ngetSQL(), ['idade' =\n $idade]);\n\n\n\n\nFrontend\n#\n\n\nO Singular Framework foi projetado para ser um framework Ajax de baixo acoplamento entre as camadas de frontend e backend, ou seja, a interface dos m\u00f3dulos que ser\u00e3o constru\u00eddos na aplica\u00e7\u00e3o, s\u00e3o definidos totalmente no frontend, sem nenhuma vincula\u00e7\u00e3o com a renderiza\u00e7\u00e3o no backend. Enquanto no backend, o Silex \u00e9 utilizado como base do framework, no frontend por sua vez \u00e9 o AngularJS quem fornece a estrutura de trabalho para a constru\u00e7\u00e3o da interface de usu\u00e1rio.\n\n\nViews renderizadas pelo backend\n#\n\n\nEm um projeto criado a partir do Singular Project, h\u00e1 inicialmente, apenas 2 views que s\u00e3o renderizadas pelo backend. Entretanto essas views n\u00e3o possuem c\u00f3digo de interface de usu\u00e1rio, elas s\u00e3o apenas p\u00e1ginas HTML que ativam uma aplica\u00e7\u00e3o AngularJS. Essas duas views s\u00e3o auth.html e secure.html, ambas est\u00e3o localizadas no diret\u00f3rio \nviews\n na raiz do projeto. \n\n\nA renderiza\u00e7\u00e3o dessas views ocorre atrav\u00e9s do controlador \nSessao\\Controller\\Main\n atrav\u00e9s dos m\u00e9todos \nshowSecure\n e \nshowAuth\n. Eles utilizam o provedor de servi\u00e7os do \nTwig\n para pegar o template das p\u00e1ginas html e renderiz\u00e1-las no navegador. \n\n\nAlgumas vezes, pode ser necess\u00e1rio criar algumas rodas adicionais para serem renderizadas pelo backend, por exemplo, suponha que a aplica\u00e7\u00e3o que voc\u00ea est\u00e1 construindo ter\u00e1 uma tela que ser\u00e1 exibida em um monitor e que para o recurso acessado, ela n\u00e3o precise que o usu\u00e1rio esteja autenticado. Ent\u00e3o, seria necess\u00e1rio criar uma outra view, para isso, crie o arquivo do template da view dentro do diret\u00f3rio views. Por exemplo: \nmonitor.html\n. Essa view ir\u00e1 fazer refer\u00eancia a uma aplica\u00e7\u00e3o pr\u00f3pria do angular. \n\n\nAp\u00f3s criar o seu template, o pr\u00f3ximo passo \u00e9 criar um novo m\u00e9todo que ser\u00e1 respons\u00e1vel por renderizar a view no controlador \nMain\n no pacote \nSessao\n. \n\n\n...\n    /**\n     * Renderiza a interface que ser\u00e1 exibida no monitor.\n     * \n     * @param Request $request\n     * \n     * @return JsonResponse\n     */\n    public function showMonitor(Request $request)\n    {\n        $app = $this-\napp;\n\n        // rederiza a p\u00e1gina de autentica\u00e7\u00e3o\n        return $app['twig']-\nrender(\nmonitor.html\n);\n    }\n...\n\n\n\n\nO m\u00e9todo render do servi\u00e7o \ntwig\n pode ainda receber par\u00e2metros adicionais que ser\u00e3o interpolados ao template, para maiores informa\u00e7\u00f5es, consulte a documenta\u00e7\u00e3o do \nProvedor de servi\u00e7os do Twig\n. \n\n\nPara que a view possa ser renderizada, ainda \u00e9 necess\u00e1rio realizar uma \u00faltima configura\u00e7\u00e3o que ir\u00e1 criar uma rota get para o m\u00e9todo de renderiza\u00e7\u00e3o da view. Para isso, adicione uma entrada para o mapeamento da rota no m\u00e9todo connect da classe SessaoServiceProvider no pacote Sessao.\n\n\n    /**\n     * Registra as rotas de inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o.\n     *\n     * @param Application $app\n     */\n    public function connect(Application $app)\n    {\n        // define o servi\u00e7o do controlador principal\n        $app['sessao.controller.main'] = function() use ($app) {\n            return new Main($app, $app['singular.packs'][$this-\npack]);\n        };\n\n        // define a rota de acesso autenticado da aplica\u00e7\u00e3o\n        $app-\nget('/secure.app', 'sessao.controller.main:showSecure')-\nbind('secure');\n\n        // define a rota de visualiza\u00e7\u00e3o da interface de registro e autentica\u00e7\u00e3o do sistema\n        $app-\nget('/auth.app', 'sessao.controller.main:showAuth')-\nbind('auth');\n\n        // define a rota default do sistema\n        $app-\nget('/', 'sessao.controller.main:index');\n\n        // define a rota para a view do monitor\n        $app-\nget('/monitor', 'sessao.controller.main:showMonitor');\n    }\n\n\n\n\nComo se trata de uma defini\u00e7\u00e3o de rota convencional do Silex, voc\u00ea pode utilizar qualquer funcionalidade ou recurso dispon\u00edveis para isso, como por exemplo, utilizar rotas din\u00e2micas com par\u00e2metros, valida\u00e7\u00e3o de par\u00e2metros, etc. \n\n\nPronto, feito isso, voc\u00ea poder\u00e1 agora acessar a view diretamente atrav\u00e9s do seu navegador.\n\n\nM\u00f3dulos\n#\n\n\nSe no backend as funcionalidades s\u00e3o agrupadas em pacotes, no frontend elas s\u00e3o agrupadas por m\u00f3dulos, esses s\u00e3o m\u00f3dulos do AngularJS, esses m\u00f3dulos podem ser dependentes de outros m\u00f3dulos menores ou subm\u00f3dulos, se assim quiser cham\u00e1-los. \n\n\nOs m\u00f3dulos de frontend s\u00e3o armazenados dentro do diret\u00f3rio \nweb/src\n. Uma aplica\u00e7\u00e3o criada a partir do Singular Project j\u00e1 vem com 3 m\u00f3dulos principais:\n\n\n\n\nlogin\n: M\u00f3dulo que define a aplica\u00e7\u00e3o utilizada na view de autentica\u00e7\u00e3o do sistema (auth.html). Ele \u00e9 respons\u00e1vel por fornecer fun\u00e7\u00f5es para autentica\u00e7\u00e3o do usu\u00e1rio;\n\n\nsecure\n: M\u00f3dulo que define a aplica\u00e7\u00e3o utilizada na view segura do sistema (secure.html). Geralmente seus novos m\u00f3dulos ser\u00e3o adicionados como depend\u00eancia para este m\u00f3dulo, de forma que, quando o usu\u00e1rio logar, seus m\u00f3dulos estar\u00e3o dispon\u00edveis na aplica\u00e7\u00e3o;\n\n\nui\n: M\u00f3dulo padr\u00e3o que define servi\u00e7os, controladores, views e diretivas utilizadas na interface do sistema. \n\n\n\n\nA estrutura de um m\u00f3dulo\n#\n\n\nUm m\u00f3dulo de frontend \u00e9 composto por um script de defini\u00e7\u00e3o e v\u00e1rios scripts de (controladores, diretivas, servi\u00e7os, views e filtros) que s\u00e3o organizados dentro de diret\u00f3rios. A id\u00e9ia \u00e9 seguir a defini\u00e7\u00e3o do \nJhon Papa\n para melhor organiza\u00e7\u00e3o do c\u00f3digo. \n\n\nAo abrir o diret\u00f3rio de um m\u00f3dulo geralmente tem-se a seguinte estrutura:\n\n\n\n\ncontrollers\n: Diret\u00f3rio onde s\u00e3o armazenados os scripts dos controladores AngularJS do m\u00f3dulo. Cada view dever\u00e1 ter seu pr\u00f3prio controlador. Podem ser criados tantos controladores quanto necess\u00e1rios e quanto menor o controlador mais organizado e bem estruturado ser\u00e1 o seu c\u00f3digo;\n\n\nservices\n: Diret\u00f3rio onde s\u00e3o armazenados os scripts dos servi\u00e7os AngularJS do m\u00f3dulo. Podem ser criados tantos servi\u00e7os quanto se fizer necess\u00e1rio. Toda comunica\u00e7\u00e3o com o backend se dar\u00e1 por meio dos servi\u00e7os que implementam o [Service Store];\n\n\ndirectives (opcional)\n: Diret\u00f3rio onde podem ser armazenadas diretivas espec\u00edficas do m\u00f3dulo em quest\u00e3o;\n\n\nfilters (opcional)\n: Diret\u00f3rio onde podem ser armazenados filtros espec\u00edficos do m\u00f3dulo em quest\u00e3o;\n\n\nmodulo.js\n: Script que define o m\u00f3dulo AngularJS. \u00c9 nessa defini\u00e7\u00e3o que s\u00e3o criados os states para as views do m\u00f3dulo. Vale lembrar que se o m\u00f3dulo se chamar login.registro, o nome do script ser\u00e1 registro.js.\n\n\n\n\nCriando um novo m\u00f3dulo\n#\n\n\nPara criar um novo m\u00f3dulo, basta utilizar o Singular Cli:\n\n\n./singular frontend:create-module app.teste\n\n\n\n\nAo executar este comando, ser\u00e1 criado um novo m\u00f3dulo no diret\u00f3rio \nweb/src\n chamado \napp.teste\n. No entanto, frequentemente, voc\u00ea precisar\u00e1 criar um subm\u00f3dulo, ou seja, um m\u00f3dulo que fica dentro de outro m\u00f3dulo como uma depend\u00eancia. Para isso, o Singular utiliza o padr\u00e3o de namespaces para nomea\u00e7\u00e3o dos m\u00f3dulos. No caso, o m\u00f3dulo \napp.teste\n est\u00e1 dentro do namespace \napp\n que representa a nossa aplica\u00e7\u00e3o. \n\n\nSuponha que seja necess\u00e1rio criar um subm\u00f3dulo \"registro\" dentro do m\u00f3dulo de login, para isso, no Singular Cli utilizar\u00edamos:\n\n\n./singular frontend:create-module login.registro --dir=login\n\n\n\n\nAo executar este comando, um novo diret\u00f3rio do m\u00f3dulo ser\u00e1 criado dentro do diret\u00f3rio do m\u00f3dulo \nlogin\n. No nome \nlogin.registro\n o namespace \u00e9 facilmente identificado pelo \nlogin.\n. Por padr\u00e3o, quando voc\u00ea cria um subm\u00f3dulo, o mesmo j\u00e1 \u00e9 registrado como uma depend\u00eancia no m\u00f3dulo pai.\n\n\nDefinindo states para o m\u00f3dulo\n#\n\n\nO Singular Project utiliza o ui-router como mecanismo de roteamento padr\u00e3o. Cada m\u00f3dulo define seus pr\u00f3prios states. Por este motivo, todas as rotas s\u00e3o definidas atrav\u00e9s de states, convencionalmente como \u00e9 feito no ui-router, dentro da fun\u00e7\u00e3o config do m\u00f3dulo:\n\n\n...\n        $stateProvider.state('usuario.cadastro', {\n            url: '/usuario/cadastro',\n            acl: 'f-cadastro-create',\n            controller: 'cadastro.CreateCtrl',\n            templateUrl: getView('create')\n        })\n...\n\n\n\n\nMas ao observar o bloco de c\u00f3digo, voc\u00ea deve ter percebido que existe um par\u00e2metro que n\u00e3o \u00e9 comum ao ui-router. O par\u00e2metro \n\"acl\"\n faz parte do Singular e ele \u00e9 utilizado para restringir o acesso de um usu\u00e1rio ao state. Ao utilizar esse par\u00e2metro, voc\u00ea garante que apenas usu\u00e1rios que possuam no seu perfil o acesso \u00e0 funcionalidade \nf-cadastro-create\n poder\u00e3o acess\u00e1-lo.\n\n\nControladores\n#\n\n\nAssim como na defini\u00e7\u00e3o do AngularJS, a principal func\u00e3o de um controlador \u00e9 integrar o modelo \u00e0 view. Cada m\u00f3dulo tem seu pr\u00f3prio conjunto de controladores, e eles se encontram no diret\u00f3rio \ncontrollers\n do m\u00f3dulo. \n\n\nCriando um novo controlador\n#\n\n\nPara criar um novo controlador, basta utilizar o Singular Cli:\n\n\n./singular frontend:create-controller namespacemodulo.MeuControlador modulo diretorio/do/submodulo --tipo=list\n\n\n\n\nOnde:\n+ \nnamespacemodulo.MeuControlador\n: deve ser substitu\u00eddo pelo nome do seu controlador com o namespace. Por exemplo: usuario.ListCtrl;\n+ \nmodulo\n: deve ser substitu\u00eddo pelo nome com namepsace completo do m\u00f3dulo onde o controlador ser\u00e1 criado. Por exemplo: cadastro.usuario;\n+ \ndiretorio/do/modulo\n: deve ser substitu\u00eddo pelo caminho completo do diret\u00f3rio do m\u00f3dulo a partir do diret\u00f3rio web/src;\n+ \ntipo\n: se omitido, o valor default \u00e9 normal. Mas pode assumir os valores (list, filter, modal, create, edit, normal);\n\n\nService Stores\n#\n\n\nService Stores s\u00e3o servi\u00e7os angular que s\u00e3o criados a partir de uma StoreFactory. Eles disponibilizam m\u00e9todos CRUD e de comunica\u00e7\u00e3o com o backend encapsulando as chamadas do servi\u00e7o $http.\n\n\nCriando um novo service store\n#\n\n\nPara criar um novo service store, basta utilizar o Singular Cli:\n\n\n./singular frontend:create-store NomedoStore modulo pack controlador dir\n\n\n\n\nOnde:\n+ \nNomedoStore\n: dever\u00e1 ser substitu\u00eddo pelo nome do service store que ser\u00e1 criado;\n+ \nmodulo\n: dever\u00e1 ser substitu\u00eddo pelo nome completo com namepsace do m\u00f3dulo onde o service store ser\u00e1 criado;\n+ \npack\n: dever\u00e1 ser substitu\u00eddo pelo nome do pacote no backend, onde se encontra o controlador com o qual o service store ir\u00e1 se comunicar;\n+ \ncontrolador\n: dever\u00e1 ser substitu\u00eddo pelo nome do controlador no backend com o qual o service store ir\u00e1 se comunicar;\n+ \ndir\n: dever\u00e1 ser substitu\u00eddo pelo caminho completo do m\u00f3dulo/subm\u00f3dulo a partir de web/src;\n\n\nM\u00e9todos CRUD dispon\u00edveis\n#\n\n\nComo mencionado, um service store \u00e9 criado a partir de um StoreFactory, com isso ele consegue acesso h\u00e1 alguns m\u00e9todos CRUD j\u00e1 implementados pelo StoreFactory que possibilitam comunica\u00e7\u00e3o e chamada dos m\u00e9todos CRUD no backend. \n\n\n\n\nget(id: integer, callback: function)\n: m\u00e9todo crud que faz a chamada do m\u00e9todo \nget\n no backend, onde um ID do registro \u00e9 passado como par\u00e2metro, a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da recupera\u00e7\u00e3o do registro no backend.\n\n\nload(callback: function)\n: m\u00e9todo crud que faz a chamada do m\u00e9todo \nfind\n no backend. Este m\u00e9todo utiliza implicitamente as propriedades \nfilter\n, \nsort\n, e \npaging\n do store como par\u00e2metros para o m\u00e9todo find, a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da recupera\u00e7\u00e3o dos registros no backend.\n\n\nsave(data: object, callback: function)\n: m\u00e9todo crud que faz a chamada do m\u00e9todo \nsave\n no backend, para criar/atualizar um registro. \u00c9 passado um objeto com a representa\u00e7\u00e3o do registro que ser\u00e1 inserido/atualizado e a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da a\u00e7\u00e3o de salvamento do registro no backend.\n\n\nremove(id: integer, callback: function, config: object)\n: m\u00e9todo crud que faz a chamada do m\u00e9todo \nremove\n no backend. Recebe como par\u00e2metro o ID do registro que ser\u00e1 exclu\u00eddo, e a fun\u00e7\u00e3o de callback que ser\u00e1 acionada ap\u00f3s a execu\u00e7\u00e3o da a\u00e7\u00e3o no backend. Pode ainda receber um objeto de configura\u00e7\u00e3o com as propriedades (title, text e success) para definir respectivamente o t\u00edtulo da modal de confirma\u00e7\u00e3o da exclus\u00e3o, o texto de confirma\u00e7\u00e3o da modal de confirma\u00e7\u00e3o da exclus\u00e3o e a mensagem exibida em caso de sucesso da exclus\u00e3o. Caso este \u00faltimo par\u00e2metro n\u00e3o seja passado, utilizar\u00e1 os valores padr\u00e3o para a modal e mensagem de confirma\u00e7\u00e3o.\n\n\n\n\nPar\u00e2metros do m\u00e9todo load\n#\n\n\nComo mencionado acima, quando chamamos o m\u00e9todo \nload\n de um service store, ele implicitamente inclui nos par\u00e2metros da chamada do m\u00e9todo \nfind\n no backend as propriedades \nfilter\n, \nsort\n e \npaging\n. Vamos analisar como esses par\u00e2metros s\u00e3o definidos e como podem ser alterados, de acordo com nossa necessidade.\n\n\nPagina\u00e7\u00e3o\n#\n\n\nA pagina\u00e7\u00e3o do m\u00e9todo load acontece pela configura\u00e7\u00e3o de um objeto com duas propriedades do Service Store, imagine que voc\u00ea tem acesso h\u00e1 um Service Store chamado UserStore.\n\n\nUserStore.paging.pageSize = 10;\nUserStore.paging.currentPage = 0;\nUserStore.load();\n\n\n\n\nAo utilizar uma \nlist view\n essas propriedades estar\u00e3o vinculadas aos atributos md-limit e md-page da diretiva \nmd-table-pagination\n, e podem ser manipuladas e alteradas diretamente pelo usu\u00e1rio na tela. \n\n\nOrdena\u00e7\u00e3o\n#\n\n\nAssim como a pagina\u00e7\u00e3o, a ordena\u00e7\u00e3o do m\u00e9todo load acontece tamb\u00e9m atrav\u00e9s da configura\u00e7\u00e3o de um objeto, \nsort\n. Em uma \nlist view\n essa propriedade \u00e9 atribu\u00edda \u00e0 diretiva \nmd-order\n no cabe\u00e7alho de uma tabela, e em conjunto com a diretiva md-order-by utilizada nas colunas do cabe\u00e7alho, definem a ordem da listagem de resultados:\n\n\ntable md-table md-row-select=\nDataStore.enableRowSelection\n ng-model=\nDataStore.selected\n\n   \nthead md-head md-order=\nDataStore.sort\n md-on-reorder=\nreloadData\n\n      \ntr md-row\n\n         \nth class=\ncol-sm-1\n/th\n\n         \nth md-column md-order-by=\nperfil\nspan\nPerfil\n/span\n/th\n\n         \nth md-column md-order-by=\nnome\nspan\nNome\n/span\n/th\n\n         \nth md-column md-order-by=\nlogin\nspan\nLogin\n/span\n/th\n\n         \nth md-column md-order-by=\nativo\nspan\nAtivo\n/span\n/th\n\n         \nth md-column\nspan\n/span\n/th\n\n      \n/tr\n\n   \n/thead\n\n...\n\n/table\n\n\n\n\nFiltros\n#\n\n\nApenas chamar um m\u00e9todo que retorna uma rela\u00e7\u00e3o de registros, sem poder aplicar um filtro aos resultados que queremos obter seria algo in\u00fatil. Por isso, ao chamar o m\u00e9todo \nload\n podemos definir filtros que ser\u00e3o enviados como par\u00e2metro e servir\u00e3o para filtrar os registros que desejamos obter. \n\n\nA forma mais simples de aplicar um filtro, \u00e9 atribuir um valor ao atributo da tabela que queremos filtrar:\n\n\nUserStore.filter.ativo = 1;\nUserStore.load();\n\n\n\n\nEsse simples filtro ser\u00e1 aplicado ao m\u00e9todo find no backend, e ele diz para trazer todos os registros onde a propriedade ativo seja igual a 1. \n\n\nAlgumas vezes, podemos desejar que os filtros sejam aplicados por similaridade, por exemplo:\n\n\nUserStore.filter.email = '%:gmail.com';\n\n\n\n\nEsse filtro ir\u00e1 retornar todos os usu\u00e1rios que possuam um email que possua a express\u00e3o \ngmail.com\n em alguma parte do valor. \n\n\nPodemos passar para um filtro qualquer condi\u00e7\u00e3o de compara\u00e7\u00e3o:\n\n\nUserStore.filter.idade = '\n=:10'; // idade maior igual h\u00e1 10\nUserStore.filter.peso = '\n=:30'; // peso menor igual h\u00e1 30\nUserStore.filter.reprovado = '\n:1'; // reprovado diferente de 1\n\n\n\n\nAo utilizar filtros simples, o Singular ir\u00e1 automaticamente vincular a propriedade do \nfilter\n \u00e0 tabela principal vinculada ao Store do backend. Entretanto, quando utilizamos joins, podemos querer vincular uma propriedade h\u00e1 um atributo de uma outra tabela na rela\u00e7\u00e3o de joins. Para isso, precisamos criar um mapa na defini\u00e7\u00e3o do  Service Store:\n\n\n        /* Script UserStore.js */\n        me.filterMap = {\n            perfil: {\n                property: 'p.perfil',\n                operation: '%'\n            }\n        };\n\n\n\n\nUtilizando o filterMap, podemos definir qual deve ser o atributo equivalente em uma tabela de um atributo de filtro no frontend. \n\n\nTamb\u00e9m podemos utilizar o filter map para determinar o tipo de opera\u00e7\u00e3o que desejamos que seja aplicada h\u00e1 um atributo, dessa forma n\u00e3o precisaremos ficar informando a toda chamada a opera\u00e7\u00e3o:\n\n\n// Ao inv\u00e9s de\nUserStore.filter.idade = '\n:10';\n\n// Equivale a utilizar um filter map\nUserStore.filterMap.idade = '\n';\nUserStore.filter.idade = 10;\nUserStore.load();\n\n\n\n\nUma outra utilidade do filterMap \u00e9 aplicar fun\u00e7\u00f5es de convers\u00e3o em um atributo antes que ele seja enviado como filtro para a fun\u00e7\u00e3o find no backend. \n\n\n/* Script UserStore.js */\nme.filterMap = {\n   status: {\n      property: 'en.status',\n      operation: '=',\n      convert: function(v){\n         if (v \n 1) {\n            return 1;\n         }\n         return 0;\n      }\n   }\n}\n\n\n\n\nFazendo a chamada de m\u00e9todos customizados\n#\n\n\nEmbora, a maioria da comunica\u00e7\u00e3o entre o frontend e backend seja a chamada de m\u00e9todos CRUD, eles n\u00e3o resolvem 100% dos problemas, e, frequentemente \u00e9 necess\u00e1rio fazer a chamada de m\u00e9todos customizados no controlador do backend anotados com \n@Route\n. Isso pode ser feito utilizando a chamada ao servi\u00e7o $http, mas o Service store possui um m\u00e9todo auxiliar que simplifica e torna f\u00e1cil a chamada e recupera\u00e7\u00e3o de resultado de m\u00e9todos customizados no backend: o m\u00e9todo \ncall\n.\n\n\nO m\u00e9todo call recebe quatro par\u00e2metros:\n\n\n\n\nmethod (string)\n: nome do m\u00e9todo que ser\u00e1 chamado no backend;\n\n\nparams (object)\n: objeto que cont\u00e9m a rela\u00e7\u00e3o de chaves e valor dos par\u00e2metros que ser\u00e3o enviados para o m\u00e9todo customizado no backend, pode ser enviado um objeto vazio;\n\n\ncallback (function)\n: fun\u00e7\u00e3o de callback que ser\u00e1 executada quando a chamada ao m\u00e9todo do backend retornar;\n\n\nconfig (object: opcional)\n: objeto que cont\u00e9m a configura\u00e7\u00e3o da chamada remota. Por padr\u00e3o, ao chamar o m\u00e9todo call, sempre \u00e9 executada uma chamada ao m\u00e9todo \npost\n, mas isso pode ser alterado mudando o valor da propriedade method do objeto de configura\u00e7\u00e3o para \nget\n, tamb\u00e9m podem ser passados par\u00e2metros na URL atrav\u00e9s da propriedade urlParams no formato string, por exemplo: \n\n\n\n\nme.call('meuMetodoGet', {}, function(response){...}, {method: 'get', urlParams: '/10'});\n\n\n\n\nViews\n#\n\n\nAs views do AngularJS s\u00e3o o que tornam poss\u00edvel a utiliza\u00e7\u00e3o do padr\u00e3o SPA (Single Page Aplication). Assim como nos controladores, cada m\u00f3dulo tem seu pr\u00f3prio conjunto de views, e elas se encontram no diret\u00f3rio \nviews\n do m\u00f3dulo. \n\n\nCriando uma nova view\n#\n\n\nPara criar uma nova view, basta utilizar o Singular Cli:\n\n\n./singular frontend:create-view view dir tipo\n\n\n\n\nOnde:\n+ \nview\n: deve ser substitu\u00eddo pelo nome da view que se est\u00e1 criando. Exemplo: usuario.cadastro;\n+ \ndiretorio/do/modulo\n: deve ser substitu\u00eddo pelo caminho completo do diret\u00f3rio do m\u00f3dulo onde a view ser\u00e1 criada a partir do diret\u00f3rio web/src;\n+ \ntipo\n: o tipo de view a ser criada (list, filter, modal, form, tab);\n\n\nTipos de view:\n\n\n\n\nlist\n: view do tipo listagem de resultados de um service store, com uma tabela com recursos de pagina\u00e7\u00e3o e bot\u00f5es de a\u00e7\u00e3o para cria\u00e7\u00e3o, exclus\u00e3o, edi\u00e7\u00e3o e visualiza\u00e7\u00e3o de um registro;\n\n\nfilter\n: view do tipo filtro de resultados de uma list view, \u00e9 a view exibida na sidebar lateral de filtros do m\u00f3dulo;\n\n\nmodal\n: view do tipo modal que ser\u00e1 exibida atrav\u00e9s do servi\u00e7o $modal;\n\n\nform\n: view do tipo formul\u00e1rio que inclui tabs do cadastro do registro. Tamb\u00e9m possui bot\u00f5es de a\u00e7\u00e3o para salvamento do registro e retorno \u00e0 tela de listagem;\n\n\ntab\n: view do tipo tab, que pode ser inclu\u00edda em uma view form.", 
            "title": "Conceitos b\u00e1sicos"
        }, 
        {
            "location": "/conceitos/#backend", 
            "text": "No backend \u00e9 onde s\u00e3o feitos todos os processamentos de l\u00f3gica de neg\u00f3cio, acesso \u00e0 base de dados, gera\u00e7\u00e3o de relat\u00f3rios, \nenvios de email, e outras tarefas semelhantes. Como mencionado anteriormente, o Singular Framework foi constru\u00eddo sobre \no Silex, mas de forma totalmente orientada a objetos.   Todo o c\u00f3digo backend de um projeto no Singular reside dentro do diret\u00f3rio  src .", 
            "title": "Backend"
        }, 
        {
            "location": "/conceitos/#singular-cli", 
            "text": "Um projeto criado com o Singular Project inclui o  Singular Command Line Interface . O  Singular\nCli  \u00e9 uma ferramenta utilit\u00e1ria que automatiza muitas tarefas no processo de desenvolvimento de aplica\u00e7\u00f5es.", 
            "title": "Singular CLI"
        }, 
        {
            "location": "/conceitos/#exibindo-os-comandos-disponiveis", 
            "text": "Para visualizar os comandos dispon\u00edveis no  Singular Cli , na raiz do seu projeto, execute o comando:  ./singular   O resultado ser\u00e1 algo como:  Available commands:\n  help                         Displays help for a command\n  list                         Lists commands\n backend\n  backend:create-command       Cria um novo comando num pacote\n  backend:create-controller    Cria um novo controlador num pacote\n  backend:create-pack          Cria e habilita um novo pacote na aplica\u00e7\u00e3o\n  backend:create-service       Cria um novo servi\u00e7o num pacote\n  backend:create-store         Cria um novo store num pacote\n  backend:disable-pack         Desabilita um pacote da aplica\u00e7\u00e3o\n  backend:enable-pack          Habilita um pacote da aplica\u00e7\u00e3o\ncomponent\n  component:create-migration   Cria migrations para inclus\u00e3o dos componentes no banco de dados\n  component:grant-full-access  Concede permiss\u00e3o de acesso a todos os componentes para um perfil\n frontend\n  frontend:create-controller   Cria um controlador de frontend na aplica\u00e7\u00e3o\n  frontend:create-module       Cria um m\u00f3dulo de frontend na aplica\u00e7\u00e3o\n  frontend:create-store        Cria um store de frontend na aplica\u00e7\u00e3o\n  frontend:create-view         Cria uma view de frontend para um m\u00f3dulo na aplica\u00e7\u00e3o\n lint\n  lint:yaml                    Lints a file and outputs encountered errors\n sessao\n  sessao:cria-perfil           Cria um novo registro de perfil na aplica\u00e7\u00e3o", 
            "title": "Exibindo os comandos dispon\u00edveis"
        }, 
        {
            "location": "/conceitos/#pacote", 
            "text": "Cada conjunto de funcionalidades \u00e9 organizado dentro de um pacote no diret\u00f3rio src. Por exemplo, se o sistema a ser \ndesenvolvido possui um conjunto de funcionalidades de cadastro, poder\u00e1 ser criado um pacote  Cadastro  \nque ir\u00e1 armazenar todas as classes relacionadas \u00e0 funcionalidade de cadastro. Quando um novo projeto \u00e9 criado com o \nSingular Project, j\u00e1 existe um pacote chamado  Sessao .", 
            "title": "Pacote"
        }, 
        {
            "location": "/conceitos/#estrutura-de-um-pacote", 
            "text": "Como dito anteriormente, um pacote \u00e9 uma forma de agrupar um conjunto de funcionalidades relacionadas. \nQuando um pacote \u00e9 criado, a seguinte estrutura de diret\u00f3rios e arquivos \u00e9 criada na raiz do diret\u00f3rio  src :   Command : Diret\u00f3rio onde s\u00e3o armazenadas as classes das tarefas que ser\u00e3o adicionadas \u00e0 linha de comando do singular para o pacote em quest\u00e3o;  Controller : Diret\u00f3rio onde s\u00e3o armazenadas as classes dos controladores, controladores s\u00e3o o canal de comunica\u00e7\u00e3o entre o frontend e o backend. Funcionam como uma API do backend disponibilizada para acesso no frontend;  Service : Diret\u00f3rio onde s\u00e3o armazenadas classes auxiliares que disponibilizam servi\u00e7os para que o container de servi\u00e7os do Silex possa disponibilizar para toda a aplica\u00e7\u00e3o;  Store : Diret\u00f3rio onde s\u00e3o armazenadas as classes que intermediam a comunica\u00e7\u00e3o da aplica\u00e7\u00e3o com o banco de dados. Cada tabela \u00e9 representada no Singular por um store;  PacoteServiceProvider.php : Arquivo de defini\u00e7\u00e3o do pacote, ele \u00e9 que registra o provedor de servi\u00e7os do pacote e o exp\u00f5e para o container de servi\u00e7os da aplica\u00e7\u00e3o.   O Singular CLI possui tarefas utilit\u00e1rias para a cria\u00e7\u00e3o de todos os recursos de um pacote, mais adiante iremos estud\u00e1-lo para conhecer as tarefas dispon\u00edveis.", 
            "title": "Estrutura de um Pacote"
        }, 
        {
            "location": "/conceitos/#criando-um-pacote", 
            "text": "A maneira mais f\u00e1cil de criar um pacote \u00e9 utilizar o Singular CLI, para isso, no terminal, no diret\u00f3rio raiz do seu projeto digite o seguinte comando:  ./singular backend:create-pack NomeDoPacote  Onde,  NomeDoPacote , dever\u00e1 ser substitu\u00eddo pelo nome do pacote que voc\u00ea deseja criar.  Ao executar este comando, um novo diret\u00f3rio nomeado de acordo com nome que voc\u00ea forneceu ao pacote ser\u00e1 criado na \nraiz do diret\u00f3rio src, com a estrutura completa de um pacote.  Al\u00e9m disso, um arquivo chamado  nomedopacote.php  \u00e9 criado dentro do diret\u00f3rio  app/packs . Ao abrir \neste arquivo, voc\u00ea pode verificar a seguinte declara\u00e7\u00e3o:  use NomeDoPacote\\NomeDoPacoteServiceProvider;\n\n$app- register(new NomeDoPacoteServiceProvider());  Uma vez que o Singular \u00e9 criado sobre o  Silex Framework , ele tamb\u00e9m utiliza a funcionalidade de provedores\nde servi\u00e7o para extender suas funcionalidades. Neste caso, cada novo pacote criado \u00e9 um novo provedor de servi\u00e7os, e \ncada funcionalidade desse pacote extende as funcionalidades do framework.", 
            "title": "Criando um pacote"
        }, 
        {
            "location": "/conceitos/#desabilitando-um-pacote", 
            "text": "Algumas vezes, pode ser necess\u00e1rio, para efeitos de testes ou por outro motivo, desativar um pacote e todas as suas \nfuncionalidades. Para fazer isso, basta apagar o arquivo  app/packs/nomedopacote.php . Mas isso pode ser feito via  Singular Cli  ./singular backend:disable-pack NomeDoPacote", 
            "title": "Desabilitando um pacote"
        }, 
        {
            "location": "/conceitos/#habilitando-um-pacote", 
            "text": "Se um pacote foi desabilitado, ou criado manualmente, para que o mesmo seja novamente ativado, \u00e9 necess\u00e1rio que ele seja\nhabilitado. Para isso, basta criar um arquivo chamado  nomedopacote.php  dentro do diret\u00f3rio  app/packs . \nDentro desse arquivo, voc\u00ea deve registrar o seu provedor de servi\u00e7os.  use NomeDoPacote\\NomeDoPacoteServiceProvider;\n\n$app- register(new NomeDoPacoteServiceProvider());  Entretanto, isso tamb\u00e9m pode ser alcan\u00e7ado de forma muito mais simples, atrav\u00e9s do  Singular Cli  ./singular backend:enable-pack NomeDoPacote", 
            "title": "Habilitando um pacote"
        }, 
        {
            "location": "/conceitos/#comando", 
            "text": "Comandos s\u00e3o tarefas que podem ser executadas pelo terminal atrav\u00e9s do Singular Cli. Comandos s\u00e3o \u00fateis para disparar \nemails, executar tarefas de limpeza de tabelas, etc. Eles podem ser acionados manualmente, ou ser programados para \nexecutar automaticamente atrav\u00e9s de ferramentas como o  cron  do linux.", 
            "title": "Comando"
        }, 
        {
            "location": "/conceitos/#criando-um-comando", 
            "text": "Cada pacote pode definir seus pr\u00f3prios comandos, e desta forma extender as funcionalidades do  Singular Cli \npara executar tarefas espec\u00edficas do pacote.   Para criar um comando, basta digitar a seguinte instru\u00e7\u00e3o no seu terminal:  ./singular backend:create-command Comando Pacote   Onde  Comando  deve ser substitu\u00eddo pelo nome script de comando  Pacote  deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo comando   Ao executar essa instru\u00e7\u00e3o, uma nova classe php, com o nome fornecido para o comando, ser\u00e1 criado no diret\u00f3rio Command \ndo seu pacote.   A estrutura dessa classe \u00e9 bem simples, ela possui apenas 2 m\u00e9todos  configure  e  execute , \nconforme veremos em detalhe abaixo:   1.  class TesteCommandCommand extends Command\n 2.  {\n 6.      public function configure()\n 7.      {\n 8.         $this- setName('sessao:teste-command')\n 9.             - setDescription('Descri\u00e7\u00e3o do comando')\n10.            - setHelp('Ajuda para execu\u00e7\u00e3o do comando')\n11.            - addArgument(\n12.                'parametro',\n13.                InputArgument::REQUIRED,\n14.                'Descricao do par\u00e2metro'\n15.            );\n16.      }\n17.\n24.      public function execute(InputInterface $input, OutputInterface $output)\n25.      {\n26.          $app = $this- getSilexApplication();\n27.\n28.          $output- writeln(sprintf(' info %s /info ', 'Comando executado com sucesso!'));\n29.      }\n30.  }  No m\u00e9todo  configure  \u00e9 feita a configura\u00e7\u00e3o do par\u00e2metro:    Entendendo  Linha 8  \u00c9 definido o nome do comando que ser\u00e1 exibido no Singular Cli, \n\u00e9 uma boa pr\u00e1tica utilizar o nome do pacote como namespace de um comando \nPor exemplo, se o comando chama-se teste o pacote cadastro, o nome deveria ser  cadastro:teste  Linha 9  \u00c9 definido o texto de defini\u00e7\u00e3o do comando, que exibe a ajuda ao usu\u00e1rio, sobre o que o \ncomando faz  Linha 10  \u00c9 definido um texto de ajuda, que ser\u00e1 exibido quando o usu\u00e1rio digitar a op\u00e7\u00e3o de ajuda \npara o seu comando  Linha 11 a 14  S\u00e3o definidos os argumentos do comando, ou par\u00e2metros, como costumamos cham\u00e1-los. \nPodem ser criados tantos argumentos quanto necess\u00e1rios. Argumentos s\u00e3o obrigat\u00f3rios, mas existe op\u00e7\u00f5es, que s\u00e3o \npar\u00e2metros opcionais    O m\u00e9todo  execute  \u00e9 acionado quando o seu comando \u00e9 executado pelo Singular Cli, ele pode acessar \nqualquer servi\u00e7o da sua aplica\u00e7\u00e3o para executar uma determinada tarefas.   Para maiores informa\u00e7\u00f5es, acesse o site da documenta\u00e7\u00e3o do  Componente Console do Symfony .", 
            "title": "Criando um comando"
        }, 
        {
            "location": "/conceitos/#criando-um-controlador", 
            "text": "Controladores s\u00e3o a interface de integra\u00e7\u00e3o e comunica\u00e7\u00e3o entre o frontend e o backend. Quando uma informa\u00e7\u00e3o do backend \u00e9 necess\u00e1ria no frontend, como por exemplo, uma lista de usu\u00e1rios, uma requisi\u00e7\u00e3o \u00e9 feita a partir da interface para um controlador, esse por sua vez, \u00e9 respons\u00e1vel por realizar as chamadas aos servi\u00e7os e stores e retornar essa informa\u00e7\u00e3o para o frontend no formato json.   Para criar um novo controlador atrav\u00e9s do Singular Cli, basta executar o seguinte c\u00f3digo:  ./singular backend:create-controller Controlador Pacote  Onde:\n+  Controlador : deve ser substitu\u00eddo pelo nome do controlador;\n+  Pacote : deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo controlador;  Ao executar essa instru\u00e7\u00e3o, uma nova classe php, com o nome fornecido para o controlador, ser\u00e1 criado no diret\u00f3rio Controller do seu pacote.  A estrutura b\u00e1sica da classe de um controlador se parece com:  /**\n * Classe Perfil\n *\n * @Controller\n *\n * @author Ot\u00e1vio Fernandes  otavio@netonsolucoes.com.br \n */\nclass Perfil extends SingularController\n{\n    use Crud;\n\n    /**\n     * Defina o store padr\u00e3o do controlador.\n     *\n     * @var $store\n     */\n    protected $store = 'perfil';\n}  O que diferencia uma classe de um controlador de uma classe qualquer \u00e9 a anota\u00e7\u00e3o  @Controller  no bloco de documenta\u00e7\u00e3o da classe. Se essa anota\u00e7\u00e3o n\u00e3o existir, n\u00e3o ser\u00e1 poss\u00edvel acessar nenhum de seus m\u00e9todos atrav\u00e9s do frontend.  Outro ponto importante, \u00e9 que, se voc\u00ea desejar que o controlador criado j\u00e1 implemente m\u00e9todos b\u00e1sicos de funcionalidade  CRUD , voc\u00ea pode utilizar o  Trait   Crud , como \u00e9 feito na linha  use Crud . Por padr\u00e3o, um controlador criado pelo Singular Cli, j\u00e1 implementa esse tra\u00e7o. Os m\u00e9todos disponibilizados pelo tra\u00e7o Crud s\u00e3o:    find : Fun\u00e7\u00e3o que recupera uma lista de registros vinculados h\u00e1 um store de acordo com par\u00e2metros de filtro, pagina\u00e7\u00e3o e ordena\u00e7\u00e3o ( filter ,  paging  e  sort );    get : Fun\u00e7\u00e3o que recupera um registro espec\u00edfico vinculado h\u00e1 um store de acordo com o par\u00e2metro  id  desse registro;    save : Fun\u00e7\u00e3o que cria/atualiza um registro espec\u00edfico vinculado h\u00e1 um store de acordo com par\u00e2metros de campos de uma tabela. Se o campo  id  for enviado na lista de par\u00e2metros o registro \u00e9 atualizado, caso contr\u00e1rio, um novo registro \u00e9 criado e o seu  id  \u00e9 retornado para o m\u00e9todo que fez a requisi\u00e7\u00e3o no frontend;    remove : Fun\u00e7\u00e3o que exclui um registro vinculado h\u00e1 um store atrav\u00e9s do seu  id  informado como par\u00e2metro.    Outro ponto muito importante a considerar \u00e9 a propriedade  $store  da classe do controlador. Essa propriedade faz refer\u00eancia direta a qual classe  store  o controlador est\u00e1 vinculado. Sem essa propriedade definida, nenhum m\u00e9todo definido pelo tra\u00e7o  Crud  ir\u00e1 funcionar. Ela deve referenciar, no min\u00fasculo, h\u00e1 uma classe store, criada no mesmo pacote do controlador. Caso n\u00e3o seja um controlador que use o tra\u00e7o Crud, ela n\u00e3o \u00e9 necess\u00e1ria.", 
            "title": "Criando um controlador"
        }, 
        {
            "location": "/conceitos/#expondo-metodos-para-o-frontend", 
            "text": "Como o objetivo de uma classe de controlador \u00e9 fornecer um m\u00e9todo de comunica\u00e7\u00e3o entre o backend e o frontend, \u00e9 extremamente necess\u00e1rio que os m\u00e9todos criados no controlador sejam \"expostos\" para o frontend. Veja como um novo m\u00e9todo pode ser criado e exposto para o frontend:  ?php\nnamespace Sessao\\Controller;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Singular\\SingularController;\nuse Singular\\Crud;\nuse Singular\\Annotation\\Controller;\nuse Singular\\Annotation\\Route;\nuse Singular\\Annotation\\Direct;\nuse Singular\\Annotation\\Value;\nuse Singular\\Annotation\\Assert;\nuse Singular\\Annotation\\Convert;\nuse Singular\\Annotation\\After;\nuse Singular\\Annotation\\Before;\n\n/**\n * Classe Perfil\n *\n * @Controller\n *\n * @author Ot\u00e1vio Fernandes  otavio@netonsolucoes.com.br \n */\nclass Perfil extends SingularController\n{\n    use Crud;\n\n    /**\n     * Defina o store padr\u00e3o do controlador.\n     *\n     * @var $store\n     */\n    protected $store = 'perfil';\n\n    /**\n     * Emite uma sauda\u00e7\u00e3o para um nome completo.\n     *\n     * @Route(method= post )\n     *\n     * @param Request $request\n     *\n     * @return \\Singular\\Response\\JsonResponse\n     */\n    public function saudacoesNomeCompleto(Request $request)\n    {\n        $app = $this- app;\n\n        $primeiroNome = $request- get('primeiro_nome');\n        $segundoNome = $request- get('segundo_nome');\n\n        return $app- json([\n            'mensagem' =  'Ol\u00e1 '.$primeiroNome.' '.$segundoNome.', seja bem vindo!'\n        ]);\n    }\n}  O m\u00e9todo  saudacoesNomeCompleto  do controlador  Perfil  do pacote  Sessao  precisa ser exposto para a camada de frontend. Para isso, utilizamos a anota\u00e7\u00e3o   @Route(method= post )  Ao utilizarmos essa anota\u00e7\u00e3o, estamos tornando poss\u00edvel que uma requisi\u00e7\u00e3o seja feita diretamente da interface por exemplo atrav\u00e9s do servi\u00e7o  $http :  $http.post('./sessao/perfil/saudacoesNomeCompleto', {primeiro_nome:  Otavio , segundo_nome:  Fernandes }, function(response){\n   alert(response.mensagem);\n});  Todos os m\u00e9todos http est\u00e3o dispon\u00edveis para serem utilizados na anota\u00e7\u00e3o  @Route  (get, post, put, delete, options). Algumas vezes, pode ser necess\u00e1rio expor uma fun\u00e7\u00e3o do controlador para mais de um m\u00e9todo http, isso pode ser facilmente alcan\u00e7ado com:  @Route(methods={ post , options })  Por padr\u00e3o, todos os par\u00e2metros s\u00e3o recuperados na fun\u00e7\u00e3o do controlador atrav\u00e9s de um objeto da classe Request que \u00e9 par\u00e2metro da fun\u00e7\u00e3o. Entretanto, algumas vezes, voc\u00ea pode necessitar passar alguns par\u00e2metros na pr\u00f3pria URL, para isso basta adicionar o nome desses par\u00e2metros na sua fun\u00e7\u00e3o:      /**\n     * Emite uma sauda\u00e7\u00e3o para um nome completo.\n     *\n     * @Route(method= get )\n     *\n     * @param Request $request\n     * @param string  $primeiroNome\n     * @param string  $segundoNome\n     *\n     * @return \\Singular\\Response\\JsonResponse\n     */\n    public function saudacoesNomeCompleto(Request $request, $primeiroNome, $segundoNome)\n    {\n        $app = $this- app;\n\n        $primeiroNome = $primeiroNome;\n        $segundoNome = $segundoNome;\n\n        return $app- json([\n            'mensagem' =  'Ol\u00e1 '.$primeiroNome.' '.$segundoNome.', seja bem vindo!'\n        ]);\n    }  E a chamada http ficaria semelhante \u00e0:  $http.get('./sessao/perfil/saudacoesNomeCompleto/Otavio/Fernandes', function(response){\n   alert(response.mensagem);\n});\n\n````\n### Criando um Servi\u00e7o\n\nServi\u00e7os s\u00e3o classes que exp\u00f5e m\u00e9todos e fun\u00e7\u00f5es utilit\u00e1rias que permitem a execu\u00e7\u00e3o de algumas l\u00f3gicas e regras de neg\u00f3cio para outras partes da aplica\u00e7\u00e3o (outros servi\u00e7os e controladores). \n\nPara criar um servi\u00e7o, basta utilizar o Singular Cli:\n\n```shell\n./singular backend:create-service NomeServico Pacote  Onde: \n+  NomeServico : deve ser substitu\u00eddo pelo nome do servi\u00e7o que se deseja criar;\n+  Pacote : deve ser substitu\u00eddo pelo nome do pacote onde se deseja criar o novo servi\u00e7o;  Todo servi\u00e7o tem acesso ao container da aplica\u00e7\u00e3o, que pode ser acessado atrav\u00e9s da propriedade $app da aplica\u00e7\u00e3o. Pelo container da aplica\u00e7\u00e3o, voc\u00ea pode acessar qualquer outro servi\u00e7o definido na aplica\u00e7\u00e3o.   Assim como com os controladores, um servi\u00e7o no Singular Framework precisa ser anotado para estar registrado no container da aplica\u00e7\u00e3o como um servi\u00e7o. Para isso, a anota\u00e7\u00e3o  @Service  deve ser utilizada.", 
            "title": "Expondo m\u00e9todos para o frontend"
        }, 
        {
            "location": "/conceitos/#acessando-servicos-do-container", 
            "text": "Frequentemente, faz-se necess\u00e1rio acessar servi\u00e7os a partir de um controlador, ou mesmo de outro servi\u00e7o. Entende-se por servi\u00e7o, qualquer classe que estiver dentro de um pacote da aplica\u00e7\u00e3o. Suponha que voc\u00ea precise acessar um servi\u00e7o chamado  CalculoSalario  que est\u00e1 definido dentro do pacote  Financeiro , para acess\u00e1-lo, basta pegar uma refer\u00eancia do container de servi\u00e7os da aplica\u00e7\u00e3o, como \u00e9 feito no pimple:  $servico = $this- app['cadastro.store.calculo_salario'];  \u00c9 poss\u00edvel acessar qualquer servi\u00e7o criado, a partir de qualquer pacote, controlador ou servi\u00e7o, simplesmente usando a anota\u00e7\u00e3o de namespace de servi\u00e7os com tr\u00eas partes. Onde a primeira parte identifica o pacote, a segunda, o diret\u00f3rio do pacote (Command, Controller, Service, Store) e a terceira o nome da classe em min\u00fasculo.", 
            "title": "Acessando servi\u00e7os do container"
        }, 
        {
            "location": "/conceitos/#criando-um-store", 
            "text": "Classes Stores s\u00e3o a camada de acesso ao banco de dados da sua aplica\u00e7\u00e3o. Cada store, pode representar uma tabela, e disponibiliza uma API de m\u00e9todos que estar\u00e3o dispon\u00edveis para servi\u00e7os e controladores que executam consultas e manipula\u00e7\u00f5es espec\u00edficas no banco de dados retornando resultados, alterando ou manipulando registros.  Para criar um store, voc\u00ea pode utilizar o Singular Cli:  ./singular backend:create-store Store Pacote tabela   Store : deve ser substitu\u00eddo pelo nome da classe do store;  Pacote : deve ser substitu\u00eddo pelo nome do pacote onde voc\u00ea deseja armazenar o novo controlador;  tabela : nome da tabela no banco de dados vinculada ao store;", 
            "title": "Criando um Store"
        }, 
        {
            "location": "/conceitos/#metodos-crud-herdados-da-classe-singularstore", 
            "text": "Uma classe store faz heran\u00e7a da classe  Singular\\SingularStore , ent\u00e3o ela herda alguns m\u00e9todos utilit\u00e1rios do tipo crud padr\u00e3o dessa classe:   find($id: integer):array : Retorna um registro de uma tabela do banco de dados pelo seu id. Recebe o  id  do registro como par\u00e2metro e retorna um array representando um registro \u00fanico da tabela.   $usuario = $app['cadastro.store.usuario']- find(1);   findOneBy($filters: array):array : Retorna um registro de uma tabela atrav\u00e9s de um array de filtros aplicados nessa tabela. Recebe um array de filtros como par\u00e2metro e retorna um array representando um registro \u00fanico da tabela.   $usuario = $app['cadastro.store.usuario']- findBy([\n      'login' =  '%:Otavio', \n      'email' =  'otavio@neton.com.br'\n]);   findBy($filters: array, $pageOpts: array, $sort: array) : Retorna um conjunto de registros que combinam com um grupo de filtros aplicado na tabela. Recebe um array de filtros como par\u00e2metro, e tamb\u00e9m pode receber par\u00e2metros de pagina\u00e7\u00e3o e ordena\u00e7\u00e3o dos resultados e retorna um array contendo um conjunto de resultados que combinam com os filtros aplicados;   $usuarios = $app['cadastro.store.usuario']- findBy(\n     ['email' =  '%:gmail.com'],\n     ['start' =  0,'limit'=  5], \n     ['nome' =  'asc']\n);   save($record:array):integer : Cria/atualiza um registro na tabela e retorna o seu id;   $usuario = ['nome' =  'Ot\u00e1vio', 'login' =  'otavio', 'senha'=  '123];\n$id = $app['cadastro.store.usuario']- save($usuario);   remove($id: integer): boolean : Remove um registro da tabela atrav\u00e9s do seu id e retorna o booleano do sucesso da opera\u00e7\u00e3o;   $excluido = $app['cadastro.store.usuario']- remove(1);   removeBy($filter: array) : boolean: Remove um ou mais registros da tabela atrav\u00e9s da combina\u00e7\u00e3o de filtros aplicados na tabela;   $excluido = $app['cadastro.store.usuario']- removeBy(['email' =  '%:gmail.com']);", 
            "title": "M\u00e9todos CRUD herdados da classe SingularStore"
        }, 
        {
            "location": "/conceitos/#perfis-de-consulta", 
            "text": "Todas as fun\u00e7\u00f5es de consulta herdadas do SingularStore, por padr\u00e3o, retornam determinados campos, aplicando joins, groupings e filtros padr\u00e3o. Isso \u00e9 \u00f3timo, pois evita a cria\u00e7\u00e3o de consultas complexas desnecess\u00e1rias agilizando o processo. Entretanto, pode haver a necessidade de trazer informa\u00e7\u00f5es diferentes, com filtros e joins diferentes, dependendo do contexto. A vers\u00e3o 2 do Singular implementa uma funcionalidade chamada  Perfis de consulta (profiles)  que permite criar v\u00e1rios perfis de consulta (campos do select, filtros, joins, groupings), dessa forma \u00e9 poss\u00edvel de acordo com o contexto, selecionar um ou outro perfil padr\u00e3o, eliminando ainda mais a necessidade de criar querys complexas para atividades triviais.  Quando voc\u00ea cria um novo store, por padr\u00e3o ele j\u00e1 define o padr\u00e3o  default  de consulta:      ...\n    /**\n     * Perfis de consulta.\n     *\n     * @var array\n     */\n    protected $profiles = [\n        'default' =  [\n            'select' =  ['t.*'],\n            'joins' =  [],\n            'filters' =  [],\n            'groupings' =  []\n        ]\n    ];\n    ...  Um perfil de consulta nada mais \u00e9 que um array de arrays estruturados. Para criar um novo perfil, basta criar um elemento na propriedade $profiles atribuindo-lhe um nome e igualando seu valor a um outro array com as propriedades:\n+  select : array com a lista dos campos que ser\u00e3o selecionadas, por padr\u00e3o o alias da tabela vinculada ao store \u00e9  t ;  [\n   'select'=  ['t.nome','t.id as codigo']\n]\n````\n+ __joins__: um array de defini\u00e7\u00e3o de um relacionamento com outra tabela. Para cada elemento do join o primeiro par\u00e2metro \u00e9 o nome da tabela relacionada, o segundo o alias, o terceiro a condi\u00e7\u00e3o de igualdade do relacionamento e o quarto e opcional, o tipo de relacionamento (left ou join), se for omitido assume o valor 'join'.\n```php\n[\n   'joins' =  [\n      ['perfil','p','p.id = u.perfil_id', 'left']\n   ]\n]   filters : um array de defini\u00e7\u00e3o dos filtros padr\u00e3o a serem aplicados na consulta.   [\n   'filters' =  [\n      'ativo' =  '1'\n   ]\n]   groupings : um array de defini\u00e7\u00e3o dos agrupamentos padr\u00e3o aplicados na consulta   [\n   'grouping' =  [\n      't.id'\n   ]\n]  Para criar um novo perfil de consulta, apenas crie um novo elemento no array $profiles e defina os valores que julgar necess\u00e1rios. Para selecionar um perfil de consulta, basta acionar o m\u00e9todo  setProfile  antes de executar uma fun\u00e7\u00e3o como (find, findBy, findOneBy).  $app['cadastro.store.usuario']- setProfile('perfil')- findBy(['id' =  ' :10']);", 
            "title": "Perfis de consulta"
        }, 
        {
            "location": "/conceitos/#criando-consultas-customizadas", 
            "text": "Embora os m\u00e9todos findBy e findOneBy possam ser muito \u00fateis e flex\u00edveis atrav\u00e9s da utiliza\u00e7\u00e3o dos perfis de consulta, algumas vezes se faz necess\u00e1rio criar consultas customizadas e complexas para realizar tarefas espec\u00edficas. Esses m\u00e9todos podem ser facilmente criados nas classes store.   A classe store, possui uma propriedade  $db  que fornece acesso \u00e0 classe de conex\u00e3o  DBAL  do Doctrine para o Silex. Para facilitar a cria\u00e7\u00e3o de consultas, e ter consultas que sejam mais leg\u00edveis, \u00e9 extremamente importante utilizar o  QueryBuilder  do Doctrine. Para recuperar uma nova inst\u00e2ncia do query builder, basta:  $qb = $this- db- createQueryBuilder();  Ao criar uma consulta customizada, geralmente, precisamos passar filtros para essa consulta. Por quest\u00f5es de seguran\u00e7a,  SEMPRE  utilize a vincula\u00e7\u00e3o de par\u00e2metros para definir filtros.  N\u00c3O UTILIZE  a vincula\u00e7\u00e3o da entrada do usu\u00e1rio diretamente na montagem da sua consulta. Vamos ver uma aplica\u00e7\u00e3o de certo e errado:  /* ERRADO */\n$qb- select('u.*')\n   - from('usuarios','u')\n   - where('u.idade   '.$idade);\n$rs = $this- db- fetchAll($qb- getSQL());\n\n/* CORRETO */\n$qb- select('u.*')\n   - from('usuarios','u')\n   - where('u.idade   :idade');\n\n$rs = $this- db- fetchAll($qb- getSQL(), ['idade' =  $idade]);", 
            "title": "Criando consultas customizadas"
        }, 
        {
            "location": "/conceitos/#frontend", 
            "text": "O Singular Framework foi projetado para ser um framework Ajax de baixo acoplamento entre as camadas de frontend e backend, ou seja, a interface dos m\u00f3dulos que ser\u00e3o constru\u00eddos na aplica\u00e7\u00e3o, s\u00e3o definidos totalmente no frontend, sem nenhuma vincula\u00e7\u00e3o com a renderiza\u00e7\u00e3o no backend. Enquanto no backend, o Silex \u00e9 utilizado como base do framework, no frontend por sua vez \u00e9 o AngularJS quem fornece a estrutura de trabalho para a constru\u00e7\u00e3o da interface de usu\u00e1rio.", 
            "title": "Frontend"
        }, 
        {
            "location": "/conceitos/#views-renderizadas-pelo-backend", 
            "text": "Em um projeto criado a partir do Singular Project, h\u00e1 inicialmente, apenas 2 views que s\u00e3o renderizadas pelo backend. Entretanto essas views n\u00e3o possuem c\u00f3digo de interface de usu\u00e1rio, elas s\u00e3o apenas p\u00e1ginas HTML que ativam uma aplica\u00e7\u00e3o AngularJS. Essas duas views s\u00e3o auth.html e secure.html, ambas est\u00e3o localizadas no diret\u00f3rio  views  na raiz do projeto.   A renderiza\u00e7\u00e3o dessas views ocorre atrav\u00e9s do controlador  Sessao\\Controller\\Main  atrav\u00e9s dos m\u00e9todos  showSecure  e  showAuth . Eles utilizam o provedor de servi\u00e7os do  Twig  para pegar o template das p\u00e1ginas html e renderiz\u00e1-las no navegador.   Algumas vezes, pode ser necess\u00e1rio criar algumas rodas adicionais para serem renderizadas pelo backend, por exemplo, suponha que a aplica\u00e7\u00e3o que voc\u00ea est\u00e1 construindo ter\u00e1 uma tela que ser\u00e1 exibida em um monitor e que para o recurso acessado, ela n\u00e3o precise que o usu\u00e1rio esteja autenticado. Ent\u00e3o, seria necess\u00e1rio criar uma outra view, para isso, crie o arquivo do template da view dentro do diret\u00f3rio views. Por exemplo:  monitor.html . Essa view ir\u00e1 fazer refer\u00eancia a uma aplica\u00e7\u00e3o pr\u00f3pria do angular.   Ap\u00f3s criar o seu template, o pr\u00f3ximo passo \u00e9 criar um novo m\u00e9todo que ser\u00e1 respons\u00e1vel por renderizar a view no controlador  Main  no pacote  Sessao .   ...\n    /**\n     * Renderiza a interface que ser\u00e1 exibida no monitor.\n     * \n     * @param Request $request\n     * \n     * @return JsonResponse\n     */\n    public function showMonitor(Request $request)\n    {\n        $app = $this- app;\n\n        // rederiza a p\u00e1gina de autentica\u00e7\u00e3o\n        return $app['twig']- render( monitor.html );\n    }\n...  O m\u00e9todo render do servi\u00e7o  twig  pode ainda receber par\u00e2metros adicionais que ser\u00e3o interpolados ao template, para maiores informa\u00e7\u00f5es, consulte a documenta\u00e7\u00e3o do  Provedor de servi\u00e7os do Twig .   Para que a view possa ser renderizada, ainda \u00e9 necess\u00e1rio realizar uma \u00faltima configura\u00e7\u00e3o que ir\u00e1 criar uma rota get para o m\u00e9todo de renderiza\u00e7\u00e3o da view. Para isso, adicione uma entrada para o mapeamento da rota no m\u00e9todo connect da classe SessaoServiceProvider no pacote Sessao.      /**\n     * Registra as rotas de inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o.\n     *\n     * @param Application $app\n     */\n    public function connect(Application $app)\n    {\n        // define o servi\u00e7o do controlador principal\n        $app['sessao.controller.main'] = function() use ($app) {\n            return new Main($app, $app['singular.packs'][$this- pack]);\n        };\n\n        // define a rota de acesso autenticado da aplica\u00e7\u00e3o\n        $app- get('/secure.app', 'sessao.controller.main:showSecure')- bind('secure');\n\n        // define a rota de visualiza\u00e7\u00e3o da interface de registro e autentica\u00e7\u00e3o do sistema\n        $app- get('/auth.app', 'sessao.controller.main:showAuth')- bind('auth');\n\n        // define a rota default do sistema\n        $app- get('/', 'sessao.controller.main:index');\n\n        // define a rota para a view do monitor\n        $app- get('/monitor', 'sessao.controller.main:showMonitor');\n    }  Como se trata de uma defini\u00e7\u00e3o de rota convencional do Silex, voc\u00ea pode utilizar qualquer funcionalidade ou recurso dispon\u00edveis para isso, como por exemplo, utilizar rotas din\u00e2micas com par\u00e2metros, valida\u00e7\u00e3o de par\u00e2metros, etc.   Pronto, feito isso, voc\u00ea poder\u00e1 agora acessar a view diretamente atrav\u00e9s do seu navegador.", 
            "title": "Views renderizadas pelo backend"
        }, 
        {
            "location": "/conceitos/#modulos", 
            "text": "Se no backend as funcionalidades s\u00e3o agrupadas em pacotes, no frontend elas s\u00e3o agrupadas por m\u00f3dulos, esses s\u00e3o m\u00f3dulos do AngularJS, esses m\u00f3dulos podem ser dependentes de outros m\u00f3dulos menores ou subm\u00f3dulos, se assim quiser cham\u00e1-los.   Os m\u00f3dulos de frontend s\u00e3o armazenados dentro do diret\u00f3rio  web/src . Uma aplica\u00e7\u00e3o criada a partir do Singular Project j\u00e1 vem com 3 m\u00f3dulos principais:   login : M\u00f3dulo que define a aplica\u00e7\u00e3o utilizada na view de autentica\u00e7\u00e3o do sistema (auth.html). Ele \u00e9 respons\u00e1vel por fornecer fun\u00e7\u00f5es para autentica\u00e7\u00e3o do usu\u00e1rio;  secure : M\u00f3dulo que define a aplica\u00e7\u00e3o utilizada na view segura do sistema (secure.html). Geralmente seus novos m\u00f3dulos ser\u00e3o adicionados como depend\u00eancia para este m\u00f3dulo, de forma que, quando o usu\u00e1rio logar, seus m\u00f3dulos estar\u00e3o dispon\u00edveis na aplica\u00e7\u00e3o;  ui : M\u00f3dulo padr\u00e3o que define servi\u00e7os, controladores, views e diretivas utilizadas na interface do sistema.", 
            "title": "M\u00f3dulos"
        }, 
        {
            "location": "/conceitos/#a-estrutura-de-um-modulo", 
            "text": "Um m\u00f3dulo de frontend \u00e9 composto por um script de defini\u00e7\u00e3o e v\u00e1rios scripts de (controladores, diretivas, servi\u00e7os, views e filtros) que s\u00e3o organizados dentro de diret\u00f3rios. A id\u00e9ia \u00e9 seguir a defini\u00e7\u00e3o do  Jhon Papa  para melhor organiza\u00e7\u00e3o do c\u00f3digo.   Ao abrir o diret\u00f3rio de um m\u00f3dulo geralmente tem-se a seguinte estrutura:   controllers : Diret\u00f3rio onde s\u00e3o armazenados os scripts dos controladores AngularJS do m\u00f3dulo. Cada view dever\u00e1 ter seu pr\u00f3prio controlador. Podem ser criados tantos controladores quanto necess\u00e1rios e quanto menor o controlador mais organizado e bem estruturado ser\u00e1 o seu c\u00f3digo;  services : Diret\u00f3rio onde s\u00e3o armazenados os scripts dos servi\u00e7os AngularJS do m\u00f3dulo. Podem ser criados tantos servi\u00e7os quanto se fizer necess\u00e1rio. Toda comunica\u00e7\u00e3o com o backend se dar\u00e1 por meio dos servi\u00e7os que implementam o [Service Store];  directives (opcional) : Diret\u00f3rio onde podem ser armazenadas diretivas espec\u00edficas do m\u00f3dulo em quest\u00e3o;  filters (opcional) : Diret\u00f3rio onde podem ser armazenados filtros espec\u00edficos do m\u00f3dulo em quest\u00e3o;  modulo.js : Script que define o m\u00f3dulo AngularJS. \u00c9 nessa defini\u00e7\u00e3o que s\u00e3o criados os states para as views do m\u00f3dulo. Vale lembrar que se o m\u00f3dulo se chamar login.registro, o nome do script ser\u00e1 registro.js.", 
            "title": "A estrutura de um m\u00f3dulo"
        }, 
        {
            "location": "/conceitos/#criando-um-novo-modulo", 
            "text": "Para criar um novo m\u00f3dulo, basta utilizar o Singular Cli:  ./singular frontend:create-module app.teste  Ao executar este comando, ser\u00e1 criado um novo m\u00f3dulo no diret\u00f3rio  web/src  chamado  app.teste . No entanto, frequentemente, voc\u00ea precisar\u00e1 criar um subm\u00f3dulo, ou seja, um m\u00f3dulo que fica dentro de outro m\u00f3dulo como uma depend\u00eancia. Para isso, o Singular utiliza o padr\u00e3o de namespaces para nomea\u00e7\u00e3o dos m\u00f3dulos. No caso, o m\u00f3dulo  app.teste  est\u00e1 dentro do namespace  app  que representa a nossa aplica\u00e7\u00e3o.   Suponha que seja necess\u00e1rio criar um subm\u00f3dulo \"registro\" dentro do m\u00f3dulo de login, para isso, no Singular Cli utilizar\u00edamos:  ./singular frontend:create-module login.registro --dir=login  Ao executar este comando, um novo diret\u00f3rio do m\u00f3dulo ser\u00e1 criado dentro do diret\u00f3rio do m\u00f3dulo  login . No nome  login.registro  o namespace \u00e9 facilmente identificado pelo  login. . Por padr\u00e3o, quando voc\u00ea cria um subm\u00f3dulo, o mesmo j\u00e1 \u00e9 registrado como uma depend\u00eancia no m\u00f3dulo pai.", 
            "title": "Criando um novo m\u00f3dulo"
        }, 
        {
            "location": "/conceitos/#definindo-states-para-o-modulo", 
            "text": "O Singular Project utiliza o ui-router como mecanismo de roteamento padr\u00e3o. Cada m\u00f3dulo define seus pr\u00f3prios states. Por este motivo, todas as rotas s\u00e3o definidas atrav\u00e9s de states, convencionalmente como \u00e9 feito no ui-router, dentro da fun\u00e7\u00e3o config do m\u00f3dulo:  ...\n        $stateProvider.state('usuario.cadastro', {\n            url: '/usuario/cadastro',\n            acl: 'f-cadastro-create',\n            controller: 'cadastro.CreateCtrl',\n            templateUrl: getView('create')\n        })\n...  Mas ao observar o bloco de c\u00f3digo, voc\u00ea deve ter percebido que existe um par\u00e2metro que n\u00e3o \u00e9 comum ao ui-router. O par\u00e2metro  \"acl\"  faz parte do Singular e ele \u00e9 utilizado para restringir o acesso de um usu\u00e1rio ao state. Ao utilizar esse par\u00e2metro, voc\u00ea garante que apenas usu\u00e1rios que possuam no seu perfil o acesso \u00e0 funcionalidade  f-cadastro-create  poder\u00e3o acess\u00e1-lo.", 
            "title": "Definindo states para o m\u00f3dulo"
        }, 
        {
            "location": "/conceitos/#controladores", 
            "text": "Assim como na defini\u00e7\u00e3o do AngularJS, a principal func\u00e3o de um controlador \u00e9 integrar o modelo \u00e0 view. Cada m\u00f3dulo tem seu pr\u00f3prio conjunto de controladores, e eles se encontram no diret\u00f3rio  controllers  do m\u00f3dulo.", 
            "title": "Controladores"
        }, 
        {
            "location": "/conceitos/#criando-um-novo-controlador", 
            "text": "Para criar um novo controlador, basta utilizar o Singular Cli:  ./singular frontend:create-controller namespacemodulo.MeuControlador modulo diretorio/do/submodulo --tipo=list  Onde:\n+  namespacemodulo.MeuControlador : deve ser substitu\u00eddo pelo nome do seu controlador com o namespace. Por exemplo: usuario.ListCtrl;\n+  modulo : deve ser substitu\u00eddo pelo nome com namepsace completo do m\u00f3dulo onde o controlador ser\u00e1 criado. Por exemplo: cadastro.usuario;\n+  diretorio/do/modulo : deve ser substitu\u00eddo pelo caminho completo do diret\u00f3rio do m\u00f3dulo a partir do diret\u00f3rio web/src;\n+  tipo : se omitido, o valor default \u00e9 normal. Mas pode assumir os valores (list, filter, modal, create, edit, normal);", 
            "title": "Criando um novo controlador"
        }, 
        {
            "location": "/conceitos/#service-stores", 
            "text": "Service Stores s\u00e3o servi\u00e7os angular que s\u00e3o criados a partir de uma StoreFactory. Eles disponibilizam m\u00e9todos CRUD e de comunica\u00e7\u00e3o com o backend encapsulando as chamadas do servi\u00e7o $http.", 
            "title": "Service Stores"
        }, 
        {
            "location": "/conceitos/#criando-um-novo-service-store", 
            "text": "Para criar um novo service store, basta utilizar o Singular Cli:  ./singular frontend:create-store NomedoStore modulo pack controlador dir  Onde:\n+  NomedoStore : dever\u00e1 ser substitu\u00eddo pelo nome do service store que ser\u00e1 criado;\n+  modulo : dever\u00e1 ser substitu\u00eddo pelo nome completo com namepsace do m\u00f3dulo onde o service store ser\u00e1 criado;\n+  pack : dever\u00e1 ser substitu\u00eddo pelo nome do pacote no backend, onde se encontra o controlador com o qual o service store ir\u00e1 se comunicar;\n+  controlador : dever\u00e1 ser substitu\u00eddo pelo nome do controlador no backend com o qual o service store ir\u00e1 se comunicar;\n+  dir : dever\u00e1 ser substitu\u00eddo pelo caminho completo do m\u00f3dulo/subm\u00f3dulo a partir de web/src;", 
            "title": "Criando um novo service store"
        }, 
        {
            "location": "/conceitos/#metodos-crud-disponiveis", 
            "text": "Como mencionado, um service store \u00e9 criado a partir de um StoreFactory, com isso ele consegue acesso h\u00e1 alguns m\u00e9todos CRUD j\u00e1 implementados pelo StoreFactory que possibilitam comunica\u00e7\u00e3o e chamada dos m\u00e9todos CRUD no backend.    get(id: integer, callback: function) : m\u00e9todo crud que faz a chamada do m\u00e9todo  get  no backend, onde um ID do registro \u00e9 passado como par\u00e2metro, a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da recupera\u00e7\u00e3o do registro no backend.  load(callback: function) : m\u00e9todo crud que faz a chamada do m\u00e9todo  find  no backend. Este m\u00e9todo utiliza implicitamente as propriedades  filter ,  sort , e  paging  do store como par\u00e2metros para o m\u00e9todo find, a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da recupera\u00e7\u00e3o dos registros no backend.  save(data: object, callback: function) : m\u00e9todo crud que faz a chamada do m\u00e9todo  save  no backend, para criar/atualizar um registro. \u00c9 passado um objeto com a representa\u00e7\u00e3o do registro que ser\u00e1 inserido/atualizado e a fun\u00e7\u00e3o de callback \u00e9 acionada com o resultado da a\u00e7\u00e3o de salvamento do registro no backend.  remove(id: integer, callback: function, config: object) : m\u00e9todo crud que faz a chamada do m\u00e9todo  remove  no backend. Recebe como par\u00e2metro o ID do registro que ser\u00e1 exclu\u00eddo, e a fun\u00e7\u00e3o de callback que ser\u00e1 acionada ap\u00f3s a execu\u00e7\u00e3o da a\u00e7\u00e3o no backend. Pode ainda receber um objeto de configura\u00e7\u00e3o com as propriedades (title, text e success) para definir respectivamente o t\u00edtulo da modal de confirma\u00e7\u00e3o da exclus\u00e3o, o texto de confirma\u00e7\u00e3o da modal de confirma\u00e7\u00e3o da exclus\u00e3o e a mensagem exibida em caso de sucesso da exclus\u00e3o. Caso este \u00faltimo par\u00e2metro n\u00e3o seja passado, utilizar\u00e1 os valores padr\u00e3o para a modal e mensagem de confirma\u00e7\u00e3o.", 
            "title": "M\u00e9todos CRUD dispon\u00edveis"
        }, 
        {
            "location": "/conceitos/#parametros-do-metodo-load", 
            "text": "Como mencionado acima, quando chamamos o m\u00e9todo  load  de um service store, ele implicitamente inclui nos par\u00e2metros da chamada do m\u00e9todo  find  no backend as propriedades  filter ,  sort  e  paging . Vamos analisar como esses par\u00e2metros s\u00e3o definidos e como podem ser alterados, de acordo com nossa necessidade.", 
            "title": "Par\u00e2metros do m\u00e9todo load"
        }, 
        {
            "location": "/conceitos/#paginacao", 
            "text": "A pagina\u00e7\u00e3o do m\u00e9todo load acontece pela configura\u00e7\u00e3o de um objeto com duas propriedades do Service Store, imagine que voc\u00ea tem acesso h\u00e1 um Service Store chamado UserStore.  UserStore.paging.pageSize = 10;\nUserStore.paging.currentPage = 0;\nUserStore.load();  Ao utilizar uma  list view  essas propriedades estar\u00e3o vinculadas aos atributos md-limit e md-page da diretiva  md-table-pagination , e podem ser manipuladas e alteradas diretamente pelo usu\u00e1rio na tela.", 
            "title": "Pagina\u00e7\u00e3o"
        }, 
        {
            "location": "/conceitos/#ordenacao", 
            "text": "Assim como a pagina\u00e7\u00e3o, a ordena\u00e7\u00e3o do m\u00e9todo load acontece tamb\u00e9m atrav\u00e9s da configura\u00e7\u00e3o de um objeto,  sort . Em uma  list view  essa propriedade \u00e9 atribu\u00edda \u00e0 diretiva  md-order  no cabe\u00e7alho de uma tabela, e em conjunto com a diretiva md-order-by utilizada nas colunas do cabe\u00e7alho, definem a ordem da listagem de resultados:  table md-table md-row-select= DataStore.enableRowSelection  ng-model= DataStore.selected \n    thead md-head md-order= DataStore.sort  md-on-reorder= reloadData \n       tr md-row \n          th class= col-sm-1 /th \n          th md-column md-order-by= perfil span Perfil /span /th \n          th md-column md-order-by= nome span Nome /span /th \n          th md-column md-order-by= login span Login /span /th \n          th md-column md-order-by= ativo span Ativo /span /th \n          th md-column span /span /th \n       /tr \n    /thead \n... /table", 
            "title": "Ordena\u00e7\u00e3o"
        }, 
        {
            "location": "/conceitos/#filtros", 
            "text": "Apenas chamar um m\u00e9todo que retorna uma rela\u00e7\u00e3o de registros, sem poder aplicar um filtro aos resultados que queremos obter seria algo in\u00fatil. Por isso, ao chamar o m\u00e9todo  load  podemos definir filtros que ser\u00e3o enviados como par\u00e2metro e servir\u00e3o para filtrar os registros que desejamos obter.   A forma mais simples de aplicar um filtro, \u00e9 atribuir um valor ao atributo da tabela que queremos filtrar:  UserStore.filter.ativo = 1;\nUserStore.load();  Esse simples filtro ser\u00e1 aplicado ao m\u00e9todo find no backend, e ele diz para trazer todos os registros onde a propriedade ativo seja igual a 1.   Algumas vezes, podemos desejar que os filtros sejam aplicados por similaridade, por exemplo:  UserStore.filter.email = '%:gmail.com';  Esse filtro ir\u00e1 retornar todos os usu\u00e1rios que possuam um email que possua a express\u00e3o  gmail.com  em alguma parte do valor.   Podemos passar para um filtro qualquer condi\u00e7\u00e3o de compara\u00e7\u00e3o:  UserStore.filter.idade = ' =:10'; // idade maior igual h\u00e1 10\nUserStore.filter.peso = ' =:30'; // peso menor igual h\u00e1 30\nUserStore.filter.reprovado = ' :1'; // reprovado diferente de 1  Ao utilizar filtros simples, o Singular ir\u00e1 automaticamente vincular a propriedade do  filter  \u00e0 tabela principal vinculada ao Store do backend. Entretanto, quando utilizamos joins, podemos querer vincular uma propriedade h\u00e1 um atributo de uma outra tabela na rela\u00e7\u00e3o de joins. Para isso, precisamos criar um mapa na defini\u00e7\u00e3o do  Service Store:          /* Script UserStore.js */\n        me.filterMap = {\n            perfil: {\n                property: 'p.perfil',\n                operation: '%'\n            }\n        };  Utilizando o filterMap, podemos definir qual deve ser o atributo equivalente em uma tabela de um atributo de filtro no frontend.   Tamb\u00e9m podemos utilizar o filter map para determinar o tipo de opera\u00e7\u00e3o que desejamos que seja aplicada h\u00e1 um atributo, dessa forma n\u00e3o precisaremos ficar informando a toda chamada a opera\u00e7\u00e3o:  // Ao inv\u00e9s de\nUserStore.filter.idade = ' :10';\n\n// Equivale a utilizar um filter map\nUserStore.filterMap.idade = ' ';\nUserStore.filter.idade = 10;\nUserStore.load();  Uma outra utilidade do filterMap \u00e9 aplicar fun\u00e7\u00f5es de convers\u00e3o em um atributo antes que ele seja enviado como filtro para a fun\u00e7\u00e3o find no backend.   /* Script UserStore.js */\nme.filterMap = {\n   status: {\n      property: 'en.status',\n      operation: '=',\n      convert: function(v){\n         if (v   1) {\n            return 1;\n         }\n         return 0;\n      }\n   }\n}", 
            "title": "Filtros"
        }, 
        {
            "location": "/conceitos/#fazendo-a-chamada-de-metodos-customizados", 
            "text": "Embora, a maioria da comunica\u00e7\u00e3o entre o frontend e backend seja a chamada de m\u00e9todos CRUD, eles n\u00e3o resolvem 100% dos problemas, e, frequentemente \u00e9 necess\u00e1rio fazer a chamada de m\u00e9todos customizados no controlador do backend anotados com  @Route . Isso pode ser feito utilizando a chamada ao servi\u00e7o $http, mas o Service store possui um m\u00e9todo auxiliar que simplifica e torna f\u00e1cil a chamada e recupera\u00e7\u00e3o de resultado de m\u00e9todos customizados no backend: o m\u00e9todo  call .  O m\u00e9todo call recebe quatro par\u00e2metros:   method (string) : nome do m\u00e9todo que ser\u00e1 chamado no backend;  params (object) : objeto que cont\u00e9m a rela\u00e7\u00e3o de chaves e valor dos par\u00e2metros que ser\u00e3o enviados para o m\u00e9todo customizado no backend, pode ser enviado um objeto vazio;  callback (function) : fun\u00e7\u00e3o de callback que ser\u00e1 executada quando a chamada ao m\u00e9todo do backend retornar;  config (object: opcional) : objeto que cont\u00e9m a configura\u00e7\u00e3o da chamada remota. Por padr\u00e3o, ao chamar o m\u00e9todo call, sempre \u00e9 executada uma chamada ao m\u00e9todo  post , mas isso pode ser alterado mudando o valor da propriedade method do objeto de configura\u00e7\u00e3o para  get , tamb\u00e9m podem ser passados par\u00e2metros na URL atrav\u00e9s da propriedade urlParams no formato string, por exemplo:    me.call('meuMetodoGet', {}, function(response){...}, {method: 'get', urlParams: '/10'});", 
            "title": "Fazendo a chamada de m\u00e9todos customizados"
        }, 
        {
            "location": "/conceitos/#views", 
            "text": "As views do AngularJS s\u00e3o o que tornam poss\u00edvel a utiliza\u00e7\u00e3o do padr\u00e3o SPA (Single Page Aplication). Assim como nos controladores, cada m\u00f3dulo tem seu pr\u00f3prio conjunto de views, e elas se encontram no diret\u00f3rio  views  do m\u00f3dulo.", 
            "title": "Views"
        }, 
        {
            "location": "/conceitos/#criando-uma-nova-view", 
            "text": "Para criar uma nova view, basta utilizar o Singular Cli:  ./singular frontend:create-view view dir tipo  Onde:\n+  view : deve ser substitu\u00eddo pelo nome da view que se est\u00e1 criando. Exemplo: usuario.cadastro;\n+  diretorio/do/modulo : deve ser substitu\u00eddo pelo caminho completo do diret\u00f3rio do m\u00f3dulo onde a view ser\u00e1 criada a partir do diret\u00f3rio web/src;\n+  tipo : o tipo de view a ser criada (list, filter, modal, form, tab);  Tipos de view:   list : view do tipo listagem de resultados de um service store, com uma tabela com recursos de pagina\u00e7\u00e3o e bot\u00f5es de a\u00e7\u00e3o para cria\u00e7\u00e3o, exclus\u00e3o, edi\u00e7\u00e3o e visualiza\u00e7\u00e3o de um registro;  filter : view do tipo filtro de resultados de uma list view, \u00e9 a view exibida na sidebar lateral de filtros do m\u00f3dulo;  modal : view do tipo modal que ser\u00e1 exibida atrav\u00e9s do servi\u00e7o $modal;  form : view do tipo formul\u00e1rio que inclui tabs do cadastro do registro. Tamb\u00e9m possui bot\u00f5es de a\u00e7\u00e3o para salvamento do registro e retorno \u00e0 tela de listagem;  tab : view do tipo tab, que pode ser inclu\u00edda em uma view form.", 
            "title": "Criando uma nova view"
        }, 
        {
            "location": "/comofazer/", 
            "text": "Alterar o tamanho da sidebar\n#\n\n\nPara alterar o tamanho da sidebar da interface de usu\u00e1rio:\n\n\nComo fazer\n#\n\n\n\n\nAltere o valor da propriedade \n@app-aside-width\n no arquivo \nweb/assets/less/app.variables.less\n do seu projeto;\n\n\nApague o arquivo \napp_less.build.css\n no diret\u00f3rio \nweb/deploy/\n do seu projeto;\n\n\nRecarregue o sistema no seu navegador.\n\n\n\n\nExemplo\n#\n\n\n@app-aside-width:                310px;", 
            "title": "Como fazer"
        }, 
        {
            "location": "/comofazer/#alterar-o-tamanho-da-sidebar", 
            "text": "Para alterar o tamanho da sidebar da interface de usu\u00e1rio:", 
            "title": "Alterar o tamanho da sidebar"
        }, 
        {
            "location": "/comofazer/#como-fazer", 
            "text": "Altere o valor da propriedade  @app-aside-width  no arquivo  web/assets/less/app.variables.less  do seu projeto;  Apague o arquivo  app_less.build.css  no diret\u00f3rio  web/deploy/  do seu projeto;  Recarregue o sistema no seu navegador.", 
            "title": "Como fazer"
        }, 
        {
            "location": "/comofazer/#exemplo", 
            "text": "@app-aside-width:                310px;", 
            "title": "Exemplo"
        }
    ]
}